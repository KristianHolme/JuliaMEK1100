[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia i MEK1100",
    "section": "",
    "text": "Forord\nDette dokumentet er en oversettelse fra Matlab til Julia av deler av kapittel 3 og 5 i boka ‚ÄúFeltteori og vektoranalyse‚Äù av Bj√∏rn Gjevik og Morten Wang Fagerland. Dokumentet er ogs√• basert p√• oversettelsen til Python av Karsten Trulsen.\nDokumentasjonen til julia kan du finne her: docs.julialang.org.",
    "crumbs": [
      "Forord"
    ]
  },
  {
    "objectID": "kapittel3.html",
    "href": "kapittel3.html",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "",
    "text": "3.1 Innledning\nVi starter med et lite avsnitt om hvorfor det kan v√¶re en god id√© √• bruke Julia, i stedet for alternativer som Matlab og Python. I likhet med Matlab er Julia laget for vitenskapelige beregninger, og har mye innebygget funksjonalitet for dette. Sammenlignet med Matlab er Julia mer moderne, det er gratis √• bruke, det er i mange tilfeller raskere enn Matlab, og det er mye enklere √• bruke kode (pakker, funksjoner, etc.) som andre har laget, eller dele din egen kode s√• andre kan bruke den.\nMange av disse fordelene gjelder ogs√• i sammenligning med Python. Python er i motsetning til Julia ikke laget spesifikt for vitenskapelige beregninger, s√• Julia kan v√¶re mer ‚Äúergonomisk‚Äù n√•r man skal gj√∏re vitenskapelige beregninger. Det kan ogs√• v√¶re vanskeligere √• f√• relativt enkle programmer til √• kj√∏re raskt, hvis man ikke er en erfaren Python-bruker.\nI dokumentasjonen til Julia kan du lese mer om forskjellene mellom Julia og andre spr√•k (inkludert Python og Matlab).\nDet finnes selvf√∏lgelig flere grunner til √• ikke bruke Julia, feks.\nI dette dokumentet vil vi bruke standard Julia for beregninger, og plotte-biblioteket Makie.jl for plotting. Makie.jl er et moderne bibliotek for datavisualisering og plotting, og er et av de mest popul√¶re plotte-bibliotekene i Julia.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#innledning",
    "href": "kapittel3.html#innledning",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "",
    "text": "Hvis man allerede har lang erfaring med Matlab eller Python, og ikke er interessert i √• l√¶re seg et nytt spr√•k.\nJulia er ikke like utbredt som Matlab og Python, s√• det kan v√¶re pakker for spesielle bruksomr√•der som ikke finnes i Julia. (Heldigvis kan man enkelt bruke Python-pakker i Julia, med pakken PythonCall.jl)\n\n\n\n\n\n\n\nNoteFor de spesielt interesserte\n\n\n\n\n\nEr du interessert i l√¶re mer om Julia og forskjeller mellom Julia, Python, og Matlab? Her er noen kilder som kan v√¶re et godt utgangspunkt:\n\nWhat‚Äôs bad about Julia?\nWhat‚Äôs great about Julia?\nWhy Numba and Cython are not substitutes for Julia\nMatlab vs.¬†Julia vs.¬†Python\nChoosing a numerical programming language\n\nN√•r det gjelder sammenligninger av ytelse, s√• er det ofte komplisert √• sammenligne hvor raske ulike spr√•k er. Spesielt √• sammenligne Julia med optimalisert Python (f.eks. med Numpy, Numba og/eller Cython). I noen tilfeller er Julia raskere, i andre tilfeller kan Python v√¶re raskere. Du har kanskje h√∏rt at man b√∏r unng√• for-l√∏kker i Python og heller bruke f.eks. vektorisering med numpy? Det er fordi numpy er skrevet i C og er veldig raskt, men Python i seg selv er tregt. I Julia er situasjonen annerledes, der er spr√•ket i seg selv (inkludert for-l√∏kker) raskt.\nDen tredje blog-posten over viser at for et spesifikt reelt problem er Julia raskere enn Optimalisert Python. Ytelse handler ogs√• mye om koden som skrives, og det fullt mulig √• skrive et Julia-program med lav ytelse (se ‚Äúperformance tips‚Äù for tips for √• unng√• dette). Uansett hvilket spr√•k man bruker s√• er det lurt √• l√¶re seg teknikker for h√∏y ytelse, hvis dette er viktig for anvendelsen din.\nTil syvende og sist faller spr√•kvalget p√• personlige preferanser, og da er det i det minste en god id√© √• v√¶re klar over alternativene f√∏r man tar et valg. (Det er selvf√∏lgelig ikke noe problem √• l√¶re seg flere spr√•k!)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#litt-grunnleggende-julia",
    "href": "kapittel3.html#litt-grunnleggende-julia",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "3.2 Litt grunnleggende Julia",
    "text": "3.2 Litt grunnleggende Julia\n\n3.2.0 Installere Julia\n√Ö installere Julia er enkelt. Det kan gj√∏res fra julialang.org/install/. Kort oppsummert: er du p√• en datamaskin med Linux eller macOS, er det bare √• kj√∏re f√∏lgende kommando i terminalen:\ncurl -fsSL https://install.julialang.org | sh\nDette installerer ogs√• programmet juliaup som er et program for √• h√•ndtere ulike versjoner, og oppgradering av Julia. Hvordan man bruker juliaup er beskrevet p√• juliaup sin github-side: github.com/JuliaLang/juliaup\nHvis du bruker Windows kan du g√• til Microsoft store, eller kj√∏re f√∏lgende kommando i kommandolinjen:\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\nHer vil vi gi en liten introduksjon til hvordan man starter med √• bruke Julia. Det finnes mange andre ressurser p√• internett som kan hjelpe deg med √• komme i gang, f.eks. denne spillelisten med korte videoer p√• YouTube.\nSt√•r du fast, vil som regel et kjapt Google-s√∏k eller en LLM-prompt (f.eks. ChatGPT) hjelpe deg. Hvis dette ikke l√∏ser problemet, kan du sp√∏rre forfatteren/oversetteren om hjelp.\n\n\n3.2.1 Oppstart, grensesnitt, kommentarer\nP√• samme m√•te som Matlab og Python, brukes Julia hovedsaklig enten i kommandolinjen/terminalen eller i et programmeringsgrensesnitt, eller en kombinasjon av de to. For √• starte Julia i terminalen skriver man julia og trykker enter:\n\nVi ser at Julia starter med en liten hilsen, og en prompt julia&gt;. Deretter kan vi skrive inn en kommando, trykke enter, og f√• svaret. For √• avslutte Julia, skriver man exit() (eller trykker enter) eller gj√∏r tastekombinasjonen Ctrl+D.\nProgrammet som kj√∏rer n√•r vi bruker Julia i kommandolinjen kalles for Julias REPL. Det st√•r for Read-Eval-Print Loop, og det er naturlig nok akkurat det en REPL gj√∏r. Den leser kommandoer, evaluerer dem, og printer ut resultatet.\n\n3.2.1.1 Hjelpemodus\nJulias REPL har flere forskjellige moduser. Den mest nyttige for en nybegynner er hjelpemodusen. Vi kan g√• inn i hjelpemodusen ved √• skrive ?. Da endres prompten fra julia&gt; til help?&gt;. I hjelpemodusen kan vi skrive inn navn p√• funksjoner, operatorer, eller andre ting, og f√• en beskrivelse av hva de gj√∏r, og eksempler p√• hvordan de kan brukes. For eksempel:\n\nFor √• g√• ut av hjelpemodusen trykker man tilbaketasten (backspace).\n\n\n3.2.1.2 Pakkemodus\nEn annen nyttig modus er pakkemodusen. De som kommer fra en bakgrunn i Python vet kanskje at det kan v√¶re vrient √• h√•ndtere pakker ved √• bruke pip, conda, anaconda, virtuelle milj√∏er, etc. I Julia er det mye enklere. Vi kan g√• inn i pakkemodusen ved √• skrive ]. Da endres prompten fra julia&gt; til (@1.12) pkg&gt;. Denne prompten betyr at vi er i grunn-milj√∏et til Julia, med versjon 1.12. I pakkemodusen kan vi gj√∏re mange kommandoer som har med pakker √• gj√∏re. For √• f√• en liste over alle tilgjengelige kommandoer, skriver man help (og trykker enter). For eksempel:\n\nHer ser vi at vi kan legge til pakker ved √• bruke kommandoen add. En pakke som alle burde ha i sitt grunn-milj√∏ er Revise.jl. Det er en pakke som gj√∏r at vi slipper √• restarte Julia hver gang vi endrer p√• kode. Her legger vi til Revise.jl:\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nHer brukte vi argumentet --startup-file no fordi vi har konfigurert Julias startup-fil til √• aktivere Revise.jl automatisk. Men her hadde vi ikke installert Revise.jl, s√• vi la til dette argumentet for √• unng√• feilmelding.\n\n\n\nAvhengig av hvor mange andre pakker vi har i milj√∏et, kan det ta noen sekunder √• installere pakker. N√•r vi installerer pakker blir koden til pakkene lasted ned og prekompilert.\nDet kan v√¶re lurt √• sette opp maskinen sin slik at Revise.jl automatisk aktiveres n√•r du starter Julia. Det kan du lese mer om her: Revise.jl config.\nN√•r vi bruker Julia i forskjellige prosjekter, l√∏nner det seg bruke spesifikke milj√∏er for hvert prosjekt. Hvis vi har en mappe som heter MEK1100 der vi har all koden vi skriver for dette faget, lager vi et eget milj√∏ for denne mappen ved √• navigere til mappen i terminalen, starte Julia, g√• inn i pakkemodusen og skrive activate . (punktumet skal v√¶re med!). Da endres prompten fra (@v1.12) pkg&gt; til (@MEK1100) pkg&gt;. Denne prompten betyr at vi er i milj√∏et for prosjektet MEK1100.\nN√• er vi i milj√∏et for prosjektet MEK1100. Her kan vi legge til de pakkene vi trenger for dette emnet. I dette milj√∏et har vi ogs√• tilgang til alle pakkene vi har i grunnmilj√∏et. N√•r vi legger til pakker i et milj√∏, vil det bli opprettet en fil som heter Project.toml i mappen. Denne filen inneholder informasjon om pakkene vi har i milj√∏et, og versjonene av pakkene. Dette gj√∏r det enkelt √• bruke andres kode; du laster ned mappen med kode (inkludert Project.toml-filen), gj√∏r pakke-kommandoen activate . og deretter instantiate. instantiate-kommandoen henter alle pakkene i Project.toml-filen og installerer de. Du kan da kj√∏re koden i mappen.\nN√•r vi skal bruke Makie.jl til plotting m√• vi velge hvilken backend vi skal bruke. Her har man flere alternativer, men enkelt sagt er det to alternativer som er mest popul√¶re. Hvis vi √∏nsker h√∏yoppl√∏ste plots vi kan eksportere som vektorgrafikk (f.eks. for √• inkludere i en rapport), bruker vi pakken CairoMakie.jl. Hvis vi er interessert i interaktivitet (zoom, rotasjon, knapper, etc.) bruker vi pakken GLMakie.jl. N√• legger vi til begge pakkene i MEK1100-milj√∏et:\n\n√Ö legge til disse pakkene kan ta litt tid, ettersom de har mye kode som skal prekompileres (jeg hadde allerede pakkene prekompilert n√•r jeg tok dette opptaket).\n\n3.2.1.2.* Hvorfor Julia er raskere enn Matlab og Python\nI motsetning til Matlab og Python, bruker Julia en s√•kalt ‚Äújust-in-time‚Äù-kompilator, som kompilerer koden til maskinkode rett f√∏r den kj√∏res, i stedet for √• kompilere koden til maskinkode n√•r den installeres. N√•r dette gj√∏res spesialiseres funksjonene for de input-argumentene du bruker. Disse to tingene: spesialisering og kompilering, er det som gj√∏r Julia raskere enn Matlab og Python, nesten like raskt som C. Ulempen med dette er det kan ta litt tid √• kj√∏re en funksjon for f√∏rste gang, fordi koden du skal kj√∏re m√• spesialiseres og kompileres. Men neste gang du kj√∏rer funksjonen vil den kj√∏re raskt, siden koden allerede er spesialisert og kompilert. Prekompilering er n√•r Julia gjetter p√• hvordan du kommer til √• bruke noen funksjoner i en pakke, og kompilerer koden til maskinkode p√• forh√•nd. Dette skjer som sagt ofte n√•r vi laster ned pakker, eller oppdaterer pakker.\n\n\n\n3.2.1.3 Julia i VS Code\nDet er vel og bra √• kun bruke Julia i terminalen, men som oftest er det enklere √• bruke Julia i et programmeringsgrensesnitt (engelsk: IDE - Integrated Development Environment). Det mest popul√¶re grensesnittet for Julia er VS Code, som er et gratis programmeringsgrensesnitt. Det kan lastes ned fra nettsiden code.visualstudio.com.\nN√•r man har installert VS Code, er det neste man m√• gj√∏re √• installere utvidelsen for Julia.\nN√•r vi har Julia-utvidelsen, kan vi starte VS Code, √•pne mappen vi skal lagre filene v√•re i (f.eks. MEK1100-mappen). Deretter kan vi starte med √• lage et script. Da kan vi lage en mappe som heter scripts, og der opprette en fil som heter script.jl. Da kan vi skrive inn koden v√•r i filen.\nN√•r vi har √•pnet filen i VS Code, kan vi starte opp Julia i VS Code med √• trykke alt + j + o. Da f√•r vi opp en Julia-REPL, som er koblet til filene v√•re. Det betyr at vi kan skrive en linje i filen v√•r, trykke ctrl + enter. S√• vil den linjen kj√∏res i v√•r REPL.\nHer f√∏lger et opptak der vi demonstrerer hvordan vi kan bruke Julia i VS Code. Vi √•pner MEK1100-mappen og starter Julia med alt + j + o. Vi √•pner en fil som inneholder kode for √• visualisere en funksjon. Deretter kj√∏rer vi filen linje for linje med shift + enter (dette gj√∏r det samme som ctrl + enter i tillegg til √• hoppe til neste linje). Resultatene av hver linje vises ved siden av linjen, og i v√•r REPL. Plottet vises i en ny fane i VS Code.\n\n\nVideo\njulia_vs_code\n\n\n\n\n3.2.1.3 Numerikk\nNumerikk i Julia gj√∏res med Array-er. I Julia er et Array en liste med elementer. Det kan v√¶re en liste med tall, en liste med strenger, en liste med funksjoner, osv. Vi kan ogs√• ha Arrayer i flere dimensjoner. Et √©n-dimensjonalt Array kalles ofte for en Vector, og et to-dimensjonalt Array kalles ofte for en Matrix. Vi kan lage en Array med klammeparenteser. Her skriver vi inn koden i filen v√•r, og trykker ctrl + enter. Da vil resultatet vises ved siden av linjen, og printes i REPL-en.\n\na = [1.2, 3.0, 4.2, 2.8]\n\n4-element Vector{Float64}:\n 1.2\n 3.0\n 4.2\n 2.8\n\n\nHer f√•r vi at resultatet er en vector, som er det samme som en 1-dimensjonal array. Vi kan ogs√• lage en array med zeros(n), ones(n), rand(n), randn(n), etc. (Du kan jo bruke hjelpemodusen for √• finne ut hva rand og randn gj√∏r!). For eksempel:\n\nzeros(3)\n\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\n\nVi kan ogs√• lage en 2-dimensjonal array med zeros(m, n), ones(m, n), rand(m, n), randn(m, n), etc. For eksempel:\n\nb = rand(2,4)\n\n2√ó4 Matrix{Float64}:\n 0.324292  0.209509  0.363866  0.48378\n 0.471127  0.48594   0.787711  0.401384\n\n\nFor √• prosessere data i arrays eller vectorer trenger vi funksjoner. I funksjoner kan vi lage funksjoner p√• flere m√•ter. Har vi en kort funksjon kan vi skrive den slik:\n\nf(x) = 3x + sin(2x)\n\nf (generic function with 1 method)\n\n\nHvis funksjonen er mer komplisert kan vi skrive den slik:\n\nfunction g(x)\n    p = x + 1\n    q = 2x - p\n    return q^2\nend\n\ng (generic function with 1 method)\n\n\nVi kan bruke funksjonene slik:\n\na = 5.9\nga = g(a)\nfa = f(a)\nprintln(\"g(a) = $(round(ga,digits=2)), f(a) = $(round(fa,digits=2))\")\n\ng(a) = 24.01, f(a) = 17.01\n\n\nHvis vi vil anvende en funksjon p√• alle elementene i en array/vektor, kan vi bruke ‚Äúbroadcasting‚Äù. Det gj√∏res ved √• skrive et punktum mellom funksjonsnavnet of argumentene:\n\nw = [1.2, 3.0, 4.2, 2.8]\ng.(w)\n\n4-element Vector{Float64}:\n  0.0399999999999999\n  4.0\n 10.240000000000002\n  3.2399999999999993\n\n\nDette fungerer ogs√• for funksjoner som har flere variabler. For eksempel:\n\nh(x, y) = x + 1000y\nu = [1.2, 3.0, 4.2, 2.8]\nw = [9.8, 4.1, 5.7, 8.7]\nh.(u, w)\n\n4-element Vector{Float64}:\n 9801.2\n 4103.0\n 5704.2\n 8702.8\n\n\nHer anvender vi funksjonen h parvis p√• elementene i vektorene u og w. Hvis vi vil anvende funksjonen p√• alle kombinasjoner av elementer i vektorene u og w, kan vi transponere den ene vektoren, s√• den blir en radvektor:\n\nw'\n\n1√ó4 adjoint(::Vector{Float64}) with eltype Float64:\n 9.8  4.1  5.7  8.7\n\n\nHer ser vi at w' er en radvektor. Apostrof er tegnet for transponering i Julia. Vi kan s√• anvende funksjonen h p√• alle kombinasjoner av elementer i vektorene u og w:\n\nM = h.(u, w')\n\n4√ó4 Matrix{Float64}:\n 9801.2  4101.2  5701.2  8701.2\n 9803.0  4103.0  5703.0  8703.0\n 9804.2  4104.2  5704.2  8704.2\n 9802.8  4102.8  5702.8  8702.8\n\n\nHer ser vi at et element \\(M_{i,j}\\) er \\(h(u[i], w[j])\\) for \\(i = 1:4\\) og \\(j = 1:4\\).\n\n\n3.2.1.4 Plotting\nN√• skal vi se kjapt p√• hvordan vi kan plotte data med Makie.jl. Her importerer vi f√∏rst CairoMakie.jl, lager noen punkter, og plotter dem.\n\nusing CairoMakie\nx = 0:0.1:2œÄ\ny = sin.(x)\nlines(x, y)\n\n\n\n\nHer brukte vi funksjonen lines som plottet linjen mellom punktene i vektorene x og y. Ofte vil vi ha litt mer kontroll over figurene vi lager, og da kan vi bruke funksjonen Figure og Axis, for √• f√∏rst lage en figur, s√• plassere en akse i figuren, og s√• plotte forskjellige ting i aksen:\n\nt = 0:0.1:2œÄ\ny = sin.(t)\nrandom_point_t = rand() .* 2œÄ\nrandom_point_y = sin(random_point_t)\n\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(ax, x, y, label=\"sin(x)\")\nscatter!(ax, random_point_t, random_point_y, label=\"Tilfeldig punkt\", markersize=16, color= :green)\nvlines!(ax, random_point_t, color=:red, linestyle=:dash)\nhlines!(ax, random_point_y, color=:red, linestyle=:dash)\naxislegend(ax)\nfig\n\n\n\n\nHer har vi brukt flere forskjellige plottefunksjoner fra Makie.jl. Bruk hjelpemodusen for √• finne ut hva de gj√∏r! Vi legger merke til at lines!-funksjonen vi brukte her sluttet med et utropstegn. Dette er en konvensjon som indikerer at funksjonen endrer p√• noen av argumentene. Her endrer vi p√• aksen, ved √• plotte en linje. Ellers er lines!-funksjonen og lines-funksjonen like. Vi kan ogs√• se at vi bruker axislegend-funksjonen til √• legge til en beskrivelse av de forskjellige plottene.\nHvis vi vil lagre figuren v√•r til en fil, kan vi bruke funksjonen save. For eksempel:\n\nfilnavn = joinpath(\"figurer\", \"sin_plot.png\")\nmkpath(\"figurer\")\nsave(filnavn, fig)\n\nHer har vi brukt funksjonen joinpath til √• lage en filsti til en mappe som heter figurer, og en fil som heter sin_plot.png. Vi har ogs√• brukt funksjonen mkpath til √• lage mappen hvis den ikke finnes.\n\n\n3.2.1.5 Emojier og symboler\nI Julia kan vi bruke emojier og matte-symboler direkte i koden v√•r. For eksempel:\n\nFor √• f√• \\(\\LaTeX\\)-symboler, kan vi bruke \\ f√∏r symbolet, slik som \\pi for \\(\\pi\\), deretter trykker vitab for √• gj√∏re om \\pi til \\(\\pi\\). For emojier bruker vi en kolon f√∏r symbolet, slik som \\:smile: for üòÑ, og trykker tab for √• gj√∏re om \\:smile: til üòÑ. Er du usikker p√• hva en emoji heter, kan du trykke tab f√∏r du har skrevet ferdig navnet, f.eks. \\:smil + tab for √• f√• opp alle emojiene der navnet begynner p√• smil.\nI tillegg til de vanlige variabeltypene (string, skalar, vektor, osv‚Ä¶) har Julia ogs√• en type som heter Symbol. Et Symbol er litt som en string, og er mye brukt i Julia. Man lager et Symbol ved √• bruke : f√∏r teksten. For eksempel:\n\na = :hei\ntypeof(a)\n\nSymbol\n\n\nHer er a av typen Symbol.\n\n\n\n3.2.2 Matriser\nI to av eksemplene overfor lagde vi en matrise ved √• bruke rand(m, n), og ved √• bruke broadcasting av en funksjon over en kolonnevektor og en radvektor. Vi kan ogs√• lage matriser ved √• skrive inn elementene direkte i en array:\n\nA = [\n    1 3 0\n    2 0 4\n    1 3 1\n]\n\n3√ó3 Matrix{Int64}:\n 1  3  0\n 2  0  4\n 1  3  1\n\n\nSom nevnt tidligere kan vi transponere matrisen ved √• skrive en apostrof etter matrisen:\n\nA'\n\n3√ó3 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  2  1\n 3  0  3\n 0  4  1\n\n\nVi kan gj√∏re flere ting med matriser, for eksempel kan vi finne den inverse matrisen ved √• skrive inv(A). For √• gj√∏re dette m√• vi benytte oss av det innebygde biblioteket LinearAlgebra.\n\nusing LinearAlgebra\nA_inv = inv(A)\n\n3√ó3 Matrix{Float64}:\n  2.0        0.5       -2.0\n -0.333333  -0.166667   0.666667\n -1.0        0.0        1.0\n\n\nN√• kan vi sjekke om dette virkelig er den inverse matrisen ved √• gange de sammen:\n\nA_inv * A\n\n3√ó3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\nVi ser at resultatet er enhetsmatrisen, s√• vi ser at dette virkelig er den inverse matrisen.\nVi kan ogs√• finne determinanten av en matrise ved √• skrive det(A).\n\ndet(A)\n\n-6.0\n\n\nOg vi kan finne summen av alle elementene i matrisen ved √• skrive sum(A).\n\nsum(A)\n\n15\n\n\nHvis vi kun vil summere over radene, eller kun kolonnene, kan vi bruke funksjonen sum med argumentet dims=1 eller dims=2. For eksempel:\n\nsum_kolonner = sum(A, dims=1)\nsum_rader = sum(A, dims=2)\n@show sum_kolonner sum_rader\n\nsum_kolonner = [4 6 5]\nsum_rader = [4; 6; 5;;]\n\n\n3√ó1 Matrix{Int64}:\n 4\n 6\n 5\n\n\nI Julia bruker matriser samme notasjon som i matematikk, dvs. \\(A_{i,j}\\) er elementet i rad \\(i\\) og kolonne \\(j\\) i matrisen \\(A\\). (i motsetning til Python, der matriser har indeksering som starter p√• 0. for det f√∏rste elementet.)\n\nA[2, 1] + A[3, 2]\n\n5\n\n\nFunksjonen size returnerer antall rader og kolonner i matrisen.\n\nsize(A)\n\n(3, 3)\n\n\nHvis vi vil ha det totale antallet elementer i matrisen, kan vi bruke funksjonen length.\n\nlength(A)\n\n9\n\n\nHvis vi vil lage oss en diagonalmatrise, kan vi bruke funksjonen diagm.\n\ndiagm([1, 2, 3])\n\n3√ó3 Matrix{Int64}:\n 1  0  0\n 0  2  0\n 0  0  3\n\n\nHvis vi vil lage oss en enhetsmatrise, kan vi bruke funksjonen eye.\n\n\n3.2.3 Kolon-operatoren og LinRange\nHvis vi vil generere en vektor med n elementer fra a til b, med jevne mellomrom, kan vi bruke LinRange-funksjonen:\n\nu = LinRange(-15, 15, 11)\n\n11-element LinRange{Float64, Int64}:\n -15.0, -12.0, -9.0, -6.0, -3.0, 0.0, 3.0, 6.0, 9.0, 12.0, 15.0\n\n\nFor √• indeksere flere elementer i en vektor eller matrise, kan vi bruke kolon-operatoren. Hvis vi vil ha element 3 til og med 5 i vektoren over indekserer vi med u[3:5].\n\nu[3:5]\n\n3-element LinRange{Float64, Int64}:\n -9.0, -6.0, -3.0\n\n\nHvis vi vil hvert tredje element fra og med element 4 og til slutten av vektoren, kan vi indeksere med u[4:3:end]. 3-tallet betyr at vi starter p√• element 4, og g√•r med 3 steg helt til vi kommer til det siste elementet i indekseringer (her bruker vi end som betyr siste indeks).\n\nu[4:3:end]\n\n3-element LinRange{Float64, Int64}:\n -6.0, 3.0, 12.0\n\n\nKolon-indeksering fungerer alts√• veldig likt som i matlab, men ganske forskjellige fra Python. I Python tar man ikke med slutt-indeksen, og steglengden er det siste tallet i indekseringen (hvis man i Python indekserer med 1:12:2 betyr det at man starter p√• det andre elementer, og g√•r med 2 steg helt til element nummer 13.) Her er noen flere eksempler:\n\nA = [\n  1 2 3 4\n  5 6 7 8\n  0 10 11 12\n  13 14 15 16\n]\n\n4√ó4 Matrix{Int64}:\n  1   2   3   4\n  5   6   7   8\n  0  10  11  12\n 13  14  15  16\n\n\n\nA[2:3, :]\n\n2√ó4 Matrix{Int64}:\n 5   6   7   8\n 0  10  11  12\n\n\nF√∏rste til tredje rad, andre til fjerde kolonne:\n\nA[1:3, 2:4]\n\n3√ó3 Matrix{Int64}:\n  2   3   4\n  6   7   8\n 10  11  12\n\n\nAndre og tredje rad, alle kolonnene:\n\nA[2:3, :]\n\n2√ó4 Matrix{Int64}:\n 5   6   7   8\n 0  10  11  12\n\n\nSteglengde 2 langs kolonnene:\n\nA[2:3, 2:2:4]\n\n2√ó2 Matrix{Int64}:\n  6   8\n 10  12\n\n\nSteglengde 3 langs kolonnene:\n\nA[2:3, 1:3:4]\n\n2√ó2 Matrix{Int64}:\n 5   8\n 0  12\n\n\n\n\n3.2.4 jl-filer og funksjoner\nSom nevnt tidligere kan vi skrive kode i filer (som alle skal slutte p√• .jl). N√•r vi skriver Julia-kode, er det mest vanlig √• kj√∏re kode i filen linje-for-linje, litt som i en Jupyter-notebook. Vi kan ogs√• kj√∏re koden i en fil uten √• f√∏rst √•pne en REPL. Her har vi et eksempel p√• en jl-fil der vi lager en matrise, og printer ut litt informasjon om den.\n\nA = [\n  1 3 0\n  2 1 1\n]\nprintln(A)\nprintln(length(A))\nprintln(size(A))\nprintln(diag(A))\nprintln(sum(A))\nprintln(A')\n\n[1 3 0; 2 1 1]\n6\n(2, 3)\n[1, 1]\n8\n[1 2; 3 1; 0 1]\n\n\nHvis vi legger denne koden i en fil som heter MatriseEksempel.jl, kan vi kj√∏re ved √• skrive julia MatriseEksempel.jl i terminalen.\nHer lager vi et litt mer komplekst eksempel, der vi lager en funksjon for √• lage tridiagonale matriser.\nusing LinearAlgebra\n\"\"\"\n  tridiag(n)\nLager en nxn-matrise med -2 p√• diagonalen og 1 p√• de to subdiagonalene.\n\"\"\"\nfunction tridiag(n)\n  identity_matrix = I(n)\n  upper_subdiagonal = Bidiagonal(zeros(n), ones(n-1), :U)\n  lower_subdiagonal = Bidiagonal(ones(n-1), zeros(n), :L)\n  A = identity_matrix + upper_subdiagonal + lower_subdiagonal\n  return A\nend\nVi legger denne filen i mappen diverse_filer. Hvis vi vil kj√∏re koden fra denne funksjonen, kan vi i en REPL skrive include(\"diverse_filer/tridiag.jl\") og s√• tridiag(5):\n\ninclude(\"diverse_filer/tridiag.jl\")\ntridiag(5)\n\n5√ó5 Tridiagonal{Float64, Vector{Float64}}:\n 1.0  1.0   ‚ãÖ    ‚ãÖ    ‚ãÖ \n 1.0  1.0  1.0   ‚ãÖ    ‚ãÖ \n  ‚ãÖ   1.0  1.0  1.0   ‚ãÖ \n  ‚ãÖ    ‚ãÖ   1.0  1.0  1.0\n  ‚ãÖ    ‚ãÖ    ‚ãÖ   1.0  1.0\n\n\nVi kan ogs√• bruke hjelpemodusen for √• finne ut hva funksjonen gj√∏r. Hjelpemodusen bruker beskrivelsen vi skrev i docstring-en til funksjonen (teksten mellom \"\"\" og \"\"\").\nhelp?&gt; tridiag\nsearch: tridiag diag isdiag Tridiagonal\n\n  tridiag(n) Lager en nxn-matrise med -2 p√• diagonalen og 1\n  p√• de to subdiagonalene.\n\n\n3.2.5 Enkel plotting i 2D\nMakie.jl har flere funksjoner for √• plotte data i 2D, noen av de har vi vist tidligere. Her kopierer vi eksempelet fra boken, og fra Python-oversettelsen:\n\nx = LinRange(-2œÄ, 2œÄ, 41)\ny = x .^ 3\nlines(x, y)\n\n\n\n\nHer har vi brukt broadcasting p√• ^-operatoren, som i likhet med matematisk notasjon betyr ‚Äúopph√∏yd i‚Äù. Siden vi vil at dette skal gj√∏res med alle elementene i vektoren x, bruker vi .-operatoren. Vi valgte her √• diskretisere \\(x\\)-intervallet med 41 punkter som gir steg p√• \\(\\frac{4\\pi}{40} = \\frac{\\pi}{10}\\). Velges dette steget for lite blir grafen hakkete. Pr√∏v f.eks. med et steg p√• \\(\\pi/2\\).\nVi kan ogs√• plotte funksjoner som er gitt ved en parametrisering. En sirkel med radius r kan uttrykkes med \\(x(t) = r \\cos(t)\\) og \\(y(t) = r \\sin(t)\\), der \\(t\\) g√•r fra 0 til \\(2\\pi\\). Vi plotter en sirkel med radius 3:\n\nt = LinRange(0, 2œÄ, 101)\nx = 3 * cos.(t)\ny = 3 * sin.(t)\nfig = Figure()\nax = Axis(fig[1, 1], aspect = DataAspect())\nlines!(ax, x, y)\nfig\n\n\n\n\nHer har vi brukt broadcasting p√• cos og sin-funksjonene, som i likhet med matematisk notasjon betyr ‚Äúcosinus‚Äù og ‚Äúsinus‚Äù. Siden vi vil at dette skal gj√∏res med alle elementene i vektoren t, bruker vi .-operatoren. Vi bruker ogs√• .-operatoren n√•r vi ganger med 3. Vi har ogs√• satt aspect = DataAspect() for at aksene skal ha samme skalering. Hvis vi ikke gj√∏r dette, kan aksene bli forskjellige skalerte, og da ville grafen se ut som en ellipse.\n\n\n3.2.6 Punktum foran en operasjon\nNoen tegn/operasjoner (f.eks. *, /, og ^) brukes til to forskjellige matematiske funksjoner. N√•r variablene disse operasjonene virker p√• er skalarer, vil den vanlige betydning (multiplikasjon og divisjon) gjelde slik at f.eks 3*2vil gi det forventede svaret 6. Hvis variablene derimot er enten vektorer eller matriser, vil operasjonene betegne de tilsvarende matriseoperasjonene. Lar vi Aog B v√¶re to matriser, vil A*B v√¶re matrisemultiplikasjon av A og B:\n\nA = [1 2; 3 4]\nB = [5 6; 7 8]\nA * B\n\n2√ó2 Matrix{Int64}:\n 19  22\n 43  50\n\n\n√ònsker vi derimot at hvert element i A skal multipliseres med det tilsvarende elementet i B, bruker vi broadcasting-operatoren . foran operasjonen, som vi var inne p√• i Seksjon 3.2.1.3 Numerikk:\n\nA .* B\n\n2√ó2 Matrix{Int64}:\n  5  12\n 21  32\n\n\nI eksempelet over der vi √∏nsket √• regne ut \\(y=x^3\\) og vi allerede har definert en vektor med \\(x\\)-verdier, vil vi at hvert element i \\(x\\) skal opph√∏yes i tredje; vi √∏nsker ikke √• bruke matrisemultiplikasjon av \\(x\\) med seg selv to ganger. Merk at dersom du √∏nsker √• multiplisere eller dividere en vektor eller en matrise med en skalar, beh√∏ver man ikke bruke broadcasting-operatoren . foran operasjonen. Her f√∏lger noen eksempler:\n\nA .*2\n\n2√ó2 Matrix{Int64}:\n 2  4\n 6  8\n\n\n\nA * 2\n\n2√ó2 Matrix{Int64}:\n 2  4\n 6  8\n\n\n\na = collect(1:4)\nprintln(a)\nprintln(a .* 2)\nprintln(a * 2)\ntry\n    a * a\ncatch e\n    io = IOBuffer()\n    showerror(io, e)\n    error_msg = String(take!(io))\n    @warn \"Det fungerer ikke √• gange en kolonnevektor med seg selv:\\n$(error_msg)\"\nend\n@info \"Vi kan gange en radvektor (a') med en kolonnevektor (a):\"\n@show a' * a\n\n\n[1, 2, 3, 4]\n[2, 4, 6, 8]\n[2, 4, 6, 8]\n‚îå Warning: Det fungerer ikke √• gange en kolonnevektor med seg selv:\n‚îÇ MethodError: no method matching *(::Vector{Int64}, ::Vector{Int64})\n‚îÇ The function `*` exists, but no method is defined for this combination of argument types.\n‚îÇ \n‚îÇ Closest candidates are:\n‚îÇ   *(::Any, ::Any, !Matched::Any, !Matched::Any...)\n‚îÇ    @ Base operators.jl:642\n‚îÇ   *(!Matched::ChainRulesCore.ZeroTangent, ::Any)\n‚îÇ    @ ChainRulesCore ~/.julia/packages/ChainRulesCore/Vsbj9/src/tangent_arithmetic.jl:104\n‚îÇ   *(!Matched::ChainRulesCore.NoTangent, ::Any)\n‚îÇ    @ ChainRulesCore ~/.julia/packages/ChainRulesCore/Vsbj9/src/tangent_arithmetic.jl:64\n‚îÇ   ...\n‚îî @ Main.Notebook ~/Code/JuliaMEK1100/kapittel3.qmd:514\n[ Info: Vi kan gange en radvektor (a') med en kolonnevektor (a):\na' * a = 30\n\n\n\n\n30\n\n\nHer brukte vi flere nye funksjoner, men frykt ikke! Hjelpemodusen er din venn!\n\ntry\n    a^2\ncatch e\n    io = IOBuffer()\n    showerror(io, e)\n    error_msg = String(take!(io))\n    @warn \"Det fungerer ikke √• opph√∏ye en kolonnevektor i andre (samme som √• gange med seg selv):\\n$(error_msg)\"\nend\n\n\n‚îå Warning: Det fungerer ikke √• opph√∏ye en kolonnevektor i andre (samme som √• gange med seg selv):\n‚îÇ MethodError: no method matching ^(::Vector{Int64}, ::Int64)\n‚îÇ The function `^` exists, but no method is defined for this combination of argument types.\n‚îÇ \n‚îÇ Closest candidates are:\n‚îÇ   ^(!Matched::Regex, ::Integer)\n‚îÇ    @ Base regex.jl:913\n‚îÇ   ^(!Matched::Missing, ::Integer)\n‚îÇ    @ Base missing.jl:155\n‚îÇ   ^(!Matched::Missing, ::Number)\n‚îÇ    @ Base missing.jl:123\n‚îÇ   ...\n‚îî @ Main.Notebook ~/Code/JuliaMEK1100/kapittel3.qmd:530\n\n\n\n\nBroadcasting kan ogs√• brukes p√• vilk√•rlige funksjoner som er definert for en enkelt type, men i situasjoner der man vil anvende funksjoner elementvis p√• en vektorer av den typen. I det f√∏lgende eksempelet bruker vi funksjonen reverse elementvis p√• en vektor med strenger:\n\n@show reverse(\"akebakke\")\nordliste = [\"eple\", \"tastatur\", \"st√∏vsuger\"]\nreverse.(ordliste)\n\nreverse(\"akebakke\") = \"ekkabeka\"\n\n\n3-element Vector{String}:\n \"elpe\"\n \"rutatsat\"\n \"regusv√∏ts\"",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#plotting-av-flater",
    "href": "kapittel3.html#plotting-av-flater",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "3.3 Plotting av flater",
    "text": "3.3 Plotting av flater\nVi skal n√• se p√• hvordan vi kan lage plottet av flaten i figur 1.7 (og 3.1) i boken. Dette er den samme flaten som vi har studert p√• side 18 i kapittel 1 og er gitt matematisk ved formelen \\[\nh = \\frac{h_0}{1 + \\frac{x^2 + y^2}{R^2}}\n\\tag{1.1}\\]\nFormelen modellerer en isolert fjelltopp der \\(h\\) er h√∏yden over havflaten, \\(h_0\\) er h√∏yden p√• toppen av fjellet, og \\(R\\) er et m√•l for radius i fjellet. Konstantene \\(h_0\\) og \\(R\\) er satt til \\(2277\\)m og \\(4000\\)m.\nDet kan v√¶re lurt √• de p√•f√∏lgende kommandoene i en REPL (eller linje for linje i en jl-fil) for √• f√• en bedre oversikt over hva som skjer.\n\n\n\nEn modell av fjelltoppen Beerenberg p√• Jan Mayen\n\n\nF√∏r vi starter, importerer vi pakkene vi trenger. Siden vi skal lage et 3D-plot, bruker vi GLMakie.jl. For √• spesifisere samme farger som i boken, bruker vi Colors.jl.\nusing GLMakie\nusing Colors\nF√∏rst definerer vi konstantene v√•re \\(h_0\\) og \\(R\\). Vi definerer ogs√• en konstant for √• konvertere kilometer til meter.\nh0 = 2277\nR = 4000\nkm = 1000\nN√• definerer vi h√∏yde-funksjonen \\(h(x, y)\\).\nh(x, y) = h0 / (1 + (x^2 + y^2) / R^2)\n\\(x\\)- og \\(y\\)-aksen skal spenne over et omr√•de p√• \\(20\\times 20\\) km med sentrum i origo. I motsetning til i Matlab og Python, trenger vi ikke √• lage et ‚Äúmeshgrid‚Äù, vi trenger bare \\(x\\)-verdiene og \\(y\\)-verdiene til punktene v√•re. Vi definerer konstanter for antallet punkter i \\(x\\)- og \\(y\\)-retningen, og lager vektorer for \\(x\\)- og \\(y\\)-verdiene.\nnx = 41\nny = 41\nx = LinRange(-10km, 10km, nx)\ny = LinRange(-10km, 10km, ny)\nAntallet punkter i hver retning m√• tilpasses for hvert eksempel, her har vi brukt 41 punkter i hver retning, som er passelig for √• unng√• at flaten blir for hakkete.\nVi lager en matrise med h√∏ydene for alle kobinasjoner av \\(x\\)- og \\(y\\)-verdiene.\n\nz = h.(x, y')\n\n101√ó101 Matrix{Float64}:\n 3.0      191.372  379.0    565.144  749.07   ‚Ä¶  -373.0    -185.372  3.0\n 2.99408  191.366  378.994  565.138  749.064     -373.006  -185.377  2.99408\n 2.97634  191.348  378.976  565.12   749.046     -373.023  -185.395  2.97634\n 2.94686  191.318  378.947  565.091  749.017     -373.053  -185.425  2.94686\n 2.90575  191.277  378.905  565.05   748.975     -373.094  -185.466  2.90575\n 2.85317  191.225  378.853  564.997  748.923  ‚Ä¶  -373.147  -185.518  2.85317\n 2.78933  191.161  378.789  564.933  748.859     -373.21   -185.582  2.78933\n 2.71448  191.086  378.714  564.858  748.784     -373.285  -185.657  2.71448\n 2.62892  191.0    378.629  564.773  748.699     -373.371  -185.743  2.62892\n 2.53298  190.905  378.533  564.677  748.603     -373.467  -185.839  2.53298\n ‚ãÆ                                            ‚ã±                      ‚ãÆ\n 2.62892  191.0    378.629  564.773  748.699     -373.371  -185.743  2.62892\n 2.71448  191.086  378.714  564.858  748.784     -373.285  -185.657  2.71448\n 2.78933  191.161  378.789  564.933  748.859     -373.21   -185.582  2.78933\n 2.85317  191.225  378.853  564.997  748.923  ‚Ä¶  -373.147  -185.518  2.85317\n 2.90575  191.277  378.905  565.05   748.975     -373.094  -185.466  2.90575\n 2.94686  191.318  378.947  565.091  749.017     -373.053  -185.425  2.94686\n 2.97634  191.348  378.976  565.12   749.046     -373.023  -185.395  2.97634\n 2.99408  191.366  378.994  565.138  749.064     -373.006  -185.377  2.99408\n 3.0      191.372  379.0    565.144  749.07   ‚Ä¶  -373.0    -185.372  3.0\n\n\nFor √• oppn√• n√∏yaktig samme farger som i boken, lager vi en matrise med farger for hvert punkt. Her blir color_matrix en matrise med nx rader og ny kolonner, der hvert element er custom_blue-fargen.\ncustom_blue = RGB(0.35, 0.67, 0.93)\ncolor_matrix = fill(custom_blue, nx, ny)\nVi lager en figur og plasserer en 3D-akse i figuren.\nfig = Figure()\nax = Axis3(fig[1, 1], xlabel=\"x [km]\", ylabel=\"y [km]\", zlabel=\"h [m]\")\nN√• er vi klare for √• plotte flaten! Her trenger vi to typer plotter: surface for √• plotte flaten, og wireframe for √• plotte rutenettet.\nsurface!(ax, x ./ km, y ./ km, z, color=color_matrix)\nwireframe!(ax, x ./ km, y ./ km, z, color=:black)\nfig\nHer har vi brukt ./-operatoren for √• dele hvert element i x og y med km for √• konvertere til kilometer.\nDet er mange muligheter for √• justere og pynte p√• plottene v√•re med Makie.jl. Har du lyst p√• litt inspirasjon, anbefales det √• se p√• Beautiful Makie, og bla litt i dokumentasjonen til Makie.jl. Her tar vi med et eksempel p√• litt mer avansert bruk av Makie.jl.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#sec-konturlinjer",
    "href": "kapittel3.html#sec-konturlinjer",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "3.4 Plotting av konturlinjer",
    "text": "3.4 Plotting av konturlinjer\nVi skal ta for oss et nytt eksempel fra kapittel 1, side 10; lufttrykket ved havoverflaten i tilknytning til et stormsenter. Formelen vi skal bruke er gitt ved\n\\[\np = p_0 - \\frac{\\Delta p}{1 + \\frac{x^2 + y^2}{R^2}}\n\\tag{1.2}\\]\nder \\(p_0\\) er lufttrykket langt borte fra sentrum, \\(\\Delta p\\) er trykkfallet inn mot sentrum og \\(R\\) er et m√•l for utstrekningen av lavtrykker. Konturlinjene vi skal plotte er gjengitt i Figur¬†1.1.\n\n\n\n\n\n\n\nFigur¬†1.1: Til venstre: konturlinjer for konstant trykk (isobarer) rundt et lavtrykkssentrum. Til h√∏yre: kontinuerlige farger for trykk.\n\n\n\n\nVi starter med konstantene som skal oppgis i km (\\(R\\)) og hPa (\\(p_0\\) og \\(\\Delta p\\)).\nR = 50\np0 = 1000\ndp = 40\nVi lager en funksjon for trykket \\(p(x, y)\\).\np(x, y) = p0 - dp / (1 + (x^2 + y^2) / R^2)\nTil forskjell fra boka skal vi her la \\(x\\)-aksen v√¶re definert over et omr√•de fra -150 til 0 km, og \\(y\\)-aksen v√¶re definert over et omr√•de fra 0 til 150 km, deretter regner vi ut p-verdiene for alle kobinasjoner av \\(x\\)- og \\(y\\)-verdiene.\nx = LinRange(-150, 0, 151)\ny = LinRange(0, 150, 151)\np_values = p.(x, y')\nVi lager en figur og plasserer en 2D-akse i figuren.\nfig = Figure()\nax_contour = Axis(fig[1,1], xlabel=\"x [km]\", ylabel=\"y [km]\", aspect=DataAspect())\nN√• plotter vi konturer med funksjonen contour!.\ncontour!(ax_contour, x, y, p_values, levels=[970, 975, 980, 985, 990, 995], \n  labels=true, linewidth=2, labelsize=15\n)\nHer har vi spesifisert at vi vil ha konturlinjer for trykkene 970, 975, 980, 985, 990 og 995 hPa. Vi har ogs√• spesifisert at vi vil ha ‚Äúlabels‚Äù (tekst p√• konturlinjene). Hvis vi vil ha andre farger kan vi bruke argumentet colormap. F.eks. colormap=:plasma, eller colormap=:jet (:jet er samme colormap som i Python-oversettelsen). For en liste over alle tilgjengelige colormaps, se Makie.jl colormaps.\nN√• vil vi lage plottet til h√∏yre i Figur¬†1.1. Her bruker vi funksjonen contourf! for √• fylle inn flatene mellom konturlinjene. F√∏rst lager vi en ny akse og plasserer den i figuren.\nax_contourf = Axis(fig[1,2], xlabel=\"x [km]\", ylabel=\"y [km]\", aspect=DataAspect())\nS√• plotter vi fyltene med funksjonen contourf!.\ncf = contourf!(ax_contourf, x, y, p_values, colormap=cmap, levels=100)\nHer har vi spesifisert at vi vil ha 100 forskjellige konturniv√•er. For √• legge til en fargebar, bruker vi funksjonen Colorbar. Vi lagrer ogs√• plotteobjektet i variabelen cf for √• kunne bruke det i funksjonen Colorbar.\nColorbar(fig[1,3], cf)\nfig\nHer har vi plassert fargebaren i figuren, og vi har brukt fig[1,3] for √• plassere den til h√∏yre for aksene. N√•r vi plasserer akser, fargebarer, og andre ting i figurer, kan vi bruke indeksering som ligner p√• matrise-indeksering. F.eks. fig[1,3] betyr plassering i rad 1, kolonne 3 i figuren.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#plotting-av-vektorfelt-og-beregning-av-gradientvektor",
    "href": "kapittel3.html#plotting-av-vektorfelt-og-beregning-av-gradientvektor",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "3.5 Plotting av vektorfelt og beregning av gradientvektor",
    "text": "3.5 Plotting av vektorfelt og beregning av gradientvektor\nEn vektor i kartesiske koordinater \\(\\mathbf v = v_x(x,y)\\mathbf i + v_y(x,y)\\mathbf j\\) kan plottes med funksjonen arrows2d.\narrows2d kan brukes p√• flere m√•ter (ta gjerne en kikk p√• dokumentasjonen). Her bruker vi den enkleste. Da trenger vi √• spesifisere punkter (gitt ved x og y-vektorer), og en funksjon som for ethvert punkt returnerer en vektor (gitt ved en x og y-komponent).\nLa oss ta et eksempel: \\[\n\\mathbf v = (x^2 + 2y - \\frac{1}{2}xy)\\mathbf i - 3y\\mathbf j\n\\]\nVi lar \\(x\\) og \\(y\\) variere mellom \\(-5\\) og \\(5\\). Vi passer p√• √• bruke st√∏rre avstand mellom punktene for at vektorene ikke skal overlappe hverandre.\n\nx = LinRange(-5, 5, 11)\ny = LinRange(-5, 5, 11)\n\n11-element LinRange{Float64, Int64}:\n -5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0\n\n\nS√• definerer vi vektorfeltet.\n\nfunction v(point)\n    x = point[1]\n    y = point[2]\n    return [(x^2 + 2y - 0.5x*y), -3y]\nend\n\nv (generic function with 1 method)\n\n\nN√• kan vi plotte vektorfeltet.\n\narrows2d(x, y, v, lengthscale=0.04)\n\n\n\n\nHer har vi skalert ned vektorene for at de ikke skal overlappe hverandre.\nN√• skal vi plotte gradientvektorer. Hvis vi har definert en en funksjon som er et skalarfelt i Julia, kan vi beregne gradienten med ForwardDiff.gradient. ForwardDiff.jl er en pakke for √• beregne gradienter numerisk. Her kan det v√¶re nyttig √• poengtere forskjellen fra hvordan dette blir gjort i boken og i Python-oversettelsen. I Python-oversettelsen brukes np.gradient for √• beregne gradienter numerisk, n√•r man har en matrise med skalarverdier. Julia har ikke en tilsvarende funksjon, men vi kan gj√∏re noe bedre! Vi kan bruke automatisk differensiering for √• beregne gradienten til funksjonen, gitt et vilk√•rlig punkt. Det finnes mange pakker for automatisk differensiering i Julia, men vi bruker her ForwardDiff.jl (legge den til MEK1100-milj√∏et i pakkemodusen!).\n\nimport ForwardDiff: gradient\nfunction h(point)\n    x = point[1]\n    y = point[2]\n    return x^2 + 2y - 0.5x*y\nend\n‚àáh(point) = gradient(h, point)\n‚àáh([1, 2])\n\n2-element Vector{Float64}:\n 1.0\n 1.5\n\n\nHer har vi definert en funksjon \\(h\\), og s√• definerer vi en funksjon ‚àáh som beregner gradienten til \\(h\\) gitt et vilk√•rlig punkt. Vi kan s√• beregne gradienten til \\(h\\) gitt punktet \\([1, 2]\\).\nMed denne gradientfunksjonen kan vi plotte gradientvektorer:\n\narrows2d(x, y, ‚àáh, lengthscale=0.04)\n\n\n\n\nN√• skal vi bruke denne teknikken til √• plotte konturlinjer og gradientvektorer for funksjonen gitt ved Ligning¬†1.1. Med noen justeringer fra eksempelet over, kan vi gj√∏re slik:\n\nusing CairoMakie\nusing ForwardDiff: gradient\n\nh0 = 2.277 # km\nR = 4 # km\n\nfunction h(point)\n    x = point[1]\n    y = point[2]\n    return h0 / (1 + (x^2 + y^2) / R^2)\nend\n\n‚àáh(point) = gradient(h, point)\n\nnx = 41\nny = 41\nx = LinRange(-10, 10, nx)\ny = LinRange(-10, 10, ny)\npoints = Point2f.(x, y') # matrise med punkter\nz = h.(points)\n\n\nx_gradient = LinRange(-10, 10, 11)\ny_gradient = LinRange(-10, 10, 11)\n\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel=\"x [km]\", ylabel=\"y [km]\", aspect=DataAspect())\narrows2d!(ax, x_gradient, y_gradient, ‚àáh, lengthscale=5)\ncontour!(ax, x, y, z, linewidth=2)\nfig\n\n\n\n\nHer legger vi merke til at vektorene st√•r vinkelrett p√• konturlinjene, akkurat som vi skulle ha forventet. For √• sikre at dette ser riktig ut, er det viktig √• bruke DataAspect() p√• aksen, slik at aksene ikke blir forskjellige skalerte.\nEttersom ForwardDiff.gradient tar inn funksjoner som tar inn et punkt, definerer vi h som en funksjon som tar inn et punkt. For √• beregne matrisen med z-verdier, bruker vi h.(points), alts√• regner vi ut \\(h\\) elementvis for alle punktene i matrisen (et element er et punkt).",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#plotting-av-str√∏mlinjer",
    "href": "kapittel3.html#plotting-av-str√∏mlinjer",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "3.6 Plotting av str√∏mlinjer",
    "text": "3.6 Plotting av str√∏mlinjer\nI kapittel 4 m√∏ter vi str√∏mfunksjonen \\(\\psi\\). Kjenner vi uttrykket for denne er det lett √• plotte str√∏mlinjene. Siden str√∏mfunksjonen er konstant langs en str√∏mlinje vil str√∏mlinjene v√¶re konturlinjer for skalarfeltet \\(\\psi\\). Vi kan derfor definere et grid med en x- og en y-vektor som tidligere, regne ut diskrete verdier av str√∏mfunksjonen for hvert punkt i gridet, og til slutt bruke contour-funksjonen for √• plotte str√∏mlinjene, p√• samme m√•te som vi plottet isobarene til trykkfeltet i seksjon 3.4 Plotting av konturlinjer.\n\n\n\n\n\n\nNote\n\n\n\nNoen ganger √∏nsker vi √• plotte str√∏mlinjer og ekviskalarflater i samme plott. I s√• fall er det et viktig poeng at de kurvefamiliene st√•r vinkelrett p√• hverandre. Dette oppn√•s ved √• kreve at enhetene langs begge aksene er like, derfor bruker vi DataAspect() p√• aksen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel3.html#oppgaver",
    "href": "kapittel3.html#oppgaver",
    "title": "Kapittel 3: Bruk av Julia",
    "section": "3.7 Oppgaver",
    "text": "3.7 Oppgaver\nOppgavene som st√•r i boka anbefales og kan gj√∏res uansett om man bruker Matlab, Python, eller Julia.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Kapittel 3: Bruk av Julia</span>"
    ]
  },
  {
    "objectID": "kapittel5.html",
    "href": "kapittel5.html",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "",
    "text": "5.1 Innledning\nHer skal vi pr√∏ve √• reprodusere noen av eksemplene fra kapittel 5 i boken. Vi bruker et litt annet datasett enn det som gj√∏res i boken. Les gjerne innledningen i kapittel 5 i boken f√∏r du begynner.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "kapittel5.html#innlesing-av-data",
    "href": "kapittel5.html#innlesing-av-data",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "5.2 Innlesing av data",
    "text": "5.2 Innlesing av data\nHer laster vi ned datasettet fra nettet (det er 18GB, s√• det kan ta litt tid).\n\nusing Downloads\nurl = \"https://thredds.met.no/thredds/fileServer/nora3_subset_atmos/atm_hourly/arome3km_1hr_200202.nc\"\ndl_path = joinpath(homedir(), \"Downloads\", \"arome3km_1hr_200202.nc\")\n\n\"/home/kristian/Downloads/arome3km_1hr_200202.nc\"\n\n\nDownloads.download(url, dl_path) # dette kan ta lang tid, filen er 18GB!\nVi leser inn datasettet med NCDatasets.jl.\n\nusing NCDatasets\nds = NCDataset(dl_path);\n\nS√• m√• vi prosessere dataene. Vi finner akkurat det tidspunktet vi vil ha, og henter ut de dataene vi trenger. Datasettet gjelder et stort omr√•de, s√• vi filtrerer ut omtrent halvparten av dataene.\n\nusing Dates\ndatetime = DateTime(2002, 2, 19, 18) # 19. Februar 2002 18:00\ntime_ix = findfirst(ds[\"time\"] .== datetime) # indeks for tiden 19. Februar 2002 18:00\n\n# filterer ut halvparten av dataene\nny_full = length(ds[\"latitude\"][1, :])\nny_sub = ny_full √∑ 2\n\np = Array(ds[\"air_pressure_at_sea_level\"][:, 1:ny_sub, 1, time_ix] ./ 100 .|&gt; Float32)\nwind_direction_from_degree = ds[\"wind_direction\"][:, 1:ny_sub, 1, time_ix] .|&gt; Float32\nwind_direction_to_rad = deg2rad.(wind_direction_from_degree)\nwind_speed = ds[\"wind_speed\"][:, 1:ny_sub, 1, time_ix] .|&gt; Float32\nu = -wind_speed .* sin.(wind_direction_to_rad)\nv = -wind_speed .* cos.(wind_direction_to_rad)\nlongitudes = Array(ds[\"longitude\"][:, 1:ny_sub]) .|&gt; Float32\nlatitudes = Array(ds[\"latitude\"][:, 1:ny_sub]) .|&gt; Float32\nxs = Array(ds[\"x\"]) .|&gt; Float32\nys = Array(ds[\"y\"])[1:ny_sub] .|&gt; Float32\n@show length(xs)\n@show length(ys)\n\nlength(xs) = 889\nlength(ys) = 744\n\n\n744\n\n\nHer ser vi at vi har \\(889 \\times 744\\) punkter i datasettet.\nN√• vil \\(p, u\\) og \\(v\\) v√¶re matriser der hvert element enten er en trykkverdi eller en komponent av vindstyrken. \\(p_{ij}\\) er alts√• en diskret representasjon av skalarfeltet \\(p(x, y)\\) som beskriver trykkfeltet i omr√•det, og \\(u_{ij}\\) og \\(v_{ij}\\) er diskrete representasjoner for komponentene av vindvektoren \\(\\mathbf v = u(x, y)\\mathbf i + v(x, y)\\mathbf j\\).\nVi kontrollerer st√∏rrelsene p√• matrisene:\n\n@show size(p)\n@show size(u)\n@show size(v)\n\nsize(p) = (889, 744)\nsize(u) = (889, 744)\nsize(v) = (889, 744)\n\n\n(889, 744)\n\n\nAlle har \\(889\\) punkter i √∏st/vest-retningen, og \\(744\\) punkter i nord/s√∏r-retningen.\nN√• kan vi plotte en ramme rundt omr√•det vi skal jobbe med, slik som i boken. For √• gj√∏re det, bruker vi pakken GeoMakie.jl. I motsetning til i boka, bruker vi ikke kartesiske koordinater, men vi bruker breddegrader og lengdegrader. I koden over er longitudes og latitudes matriser som beskriver lengdegradene og breddegradene til hvert punkt i datasettet.\n\nusing CairoMakie\nusing GeoMakie\nlimits = ((-22, 7), (52, 67))\nbottom_points = Point2f.(Array(longitudes[:, 1]), Array(latitudes[:, 1]))\nright_points = Point2f.(Array(longitudes[end, :]), Array(latitudes[end, :]))\ntop_points = Point2f.(Array(longitudes[:, end]), Array(latitudes[:, end]))\nleft_points = Point2f.(Array(longitudes[1, :]), Array(latitudes[1, :]))\npoints = vcat(bottom_points, right_points, reverse(top_points), reverse(left_points))\n\nfig = Figure(size=(800, 400))\nax = GeoAxis(fig[1, 1]; limits = ((-30, 30), (40, 80)))\nlines!(ax, GeoMakie.coastlines(50), color=:black)\nlines!(ax, points)\nfig\n\n\n\n\n\n\nFigur¬†2.1: V√¶rdata som vi skal behandle er innenfor det innrammede omr√•det p√• kartet.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "kapittel5.html#plotting-av-isobarer",
    "href": "kapittel5.html#plotting-av-isobarer",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "5.3 Plotting av isobarer",
    "text": "5.3 Plotting av isobarer\nVi kan n√• plotte konturlinjer til trykket (isobarer). For √• finne et riktig antall konturlinjer med passende trykkverdier kreves det gjerne litt eksperimentering. For dette feltet passer det bra med jevnt fordelte isobarer fra \\(980\\) hPa til \\(1025\\) hPa med \\(5\\) hPa differanse. Husk at trykket er gitt som en matrise p.\n\nisobarer = 980:5:1025\nfig = Figure(size=(800, 400))\nax = GeoAxis(fig[1, 1]; limits)\ncontour!(ax, longitudes, latitudes, p, levels=isobarer,\n    labels=true, linewidth=2, labelsize=15\n)\nlines!(ax, GeoMakie.coastlines(50), color=:black)\nfig\n\n\nIsobarene \\(p = 980, 985, \\dots, 1025\\) hPa. Trykkfeltet viser et langstrakt lavtrykkomr√•de som ligger mellom Skottland og Island, i likhet med det vi s√• i boka.\n\n\nVi kan ogs√• plotte trykkfeltet med innfylling av flatene mellom konturlinjene med contourf!.\n\nfig = Figure(size=(800, 400))\nax = GeoAxis(fig[1, 1]; limits)\ncf = contourf!(ax, longitudes, latitudes, p, colormap=:viridis, levels=100)\nlines!(ax, GeoMakie.coastlines(50), color=:black)\nColorbar(fig[1, 2], cf, label=\"Trykk (hPa)\")\nfig",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "kapittel5.html#plotting-av-vindfelt",
    "href": "kapittel5.html#plotting-av-vindfelt",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "5.4 Plotting av vindfelt",
    "text": "5.4 Plotting av vindfelt\nSiden vi n√• har vindkomponentene gitt som to like store matriser kan vi enkelt plotte vindfeltet. Her passer vi p√• √• ikke bruke alle punktene, da det ville gitt veldig mange piler. Vi bruker her en steglengde p√• \\(20\\) punkter i hver retning. Vi plotter ogs√• trykkfeltet.\n\nsteg = 20\nfig = Figure(size=(800, 400))\nax = GeoAxis(fig[1, 1]; limits)\ncontourf!(ax, longitudes, latitudes, p, levels = 100, colormap = :viridis)\narrows2d!(ax, \n    longitudes[1:steg:end, 1:steg:end], \n    latitudes[1:steg:end, 1:steg:end], \n    u[1:steg:end, 1:steg:end], \n    v[1:steg:end, 1:steg:end], \n    lengthscale=0.03, color=:orange\n)\nlines!(ax, GeoMakie.coastlines(50), color=:black)\nfig\n\n\n\n\n\n\nFigur¬†2.2: Vindfeltet visualisert som piler som viser vindretning og -styrke.\n\n\n\n\nVi kan ogs√• plotte konturlinjer for vindstyrken, med innfylling av flatene mellom konturlinjene.\n\nfig = Figure(size = (800, 400))\nax = GeoAxis(fig[1, 1]; limits)\ncf = contourf!(ax, longitudes, latitudes, wind_speed, colormap = :viridis, levels = 100)\nlines!(ax, GeoMakie.coastlines(50), color = :black)\nColorbar(fig[1, 2], cf, label = \"Vindstyrke (m/s)\")\nfig\n\n\n\n\n\n\nFigur¬†2.3: Konturlinjer for vindstyrke, med innfylling av flatene mellom konturlinjene.\n\n\n\n\nHer ser vi mye kult! Her kan vi merke oss at vindstyrke-dataene gjelder i en h√∏yde av \\(10\\) meter over bakken:\n\ndisplay(ds[\"wind_speed\"])\ndisplay(ds[\"height4\"])\ndisplay(ds[\"height4\"][1])\n\n\nwind_speed (889 √ó 1489 √ó 1 √ó 672)\n  Datatype:    Union{Missing, Float32} (Float32)\n  Dimensions:  x √ó y √ó height4 √ó time\n  Attributes:\n   _FillValue           = 9.96921e36\n   long_name            = Wind direction\n   standard_name        = wind_speed\n   units                = m/s\n   grid_mapping         = projection_lambert\n   coordinates          = longitude latitude\n\n\n\n\n\nheight4 (1)\n  Datatype:    Float32 (Float32)\n  Dimensions:  height4\n  Attributes:\n   description          = height above ground\n   long_name            = height\n   positive             = up\n   units                = m\n\n\n\n\n10.0f0",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "kapittel5.html#divergens",
    "href": "kapittel5.html#divergens",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "5.5 Divergens",
    "text": "5.5 Divergens\nDivergensen til et vektorfelt er en skalar st√∏rrelse. Denne st√∏rrelsen kan vi beregne i Julia dersom vi kjenner komponentene til vektorfeltet. Vindfeltet har komponenter \\(u\\) og \\(v\\), og uttrykket for divergensen er \\[\n\\nabla \\cdot \\mathbf v = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n\\]\nHer hvor \\(u\\) og \\(v\\) er kjent bare i gitterpunktene ved matrisene \\(u_{ij}\\) og \\(v_{ij}\\), er de deriverte i uttrykket for divergensen approksimert med \\[\n\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{i+1,j} - u_{i-1,j}}{\\Delta x}, \\text{ og }\\\\\n\\frac{\\partial v}{\\partial y} \\approx \\frac{v_{i,j+1} - v_{i,j-1}}{\\Delta y}\n\\]\nHer lager vi en funksjon for √• beregne divergensen numerisk. N√•r vi er p√• randen av omr√•det bruker vi ensidige differanser, mens vi i indre punkter bruker sentrale differanser som i ligningen over.\n\n\"\"\"\n    punkt_divergens(u, v, i, j, Œîx, Œîy)\nBeregner divergensen i punktet med indeks (i, j) med ensidige og sentrale differanser.\n\nArgumenter:\n- u: Matrise med u-komponenten av vinden\n- v: Matrise med v-komponenten av vinden\n- i: Indeks i x-retningen\n- j: Indeks i y-retningen\n- Œîx: Steglengde i x-retningen\n- Œîy: Steglengde i y-retningen\n\nReturnerer:\nDivergensen i punktet (i, j)\n\"\"\"\nfunction punkt_divergens(u, v, i, j, Œîx, Œîy)\n    if i == 1\n        dudx = (u[i + 1, j] - u[i, j]) / Œîx\n    elseif i == size(u, 1)\n        dudx = (u[i, j] - u[i - 1, j]) / Œîx\n    else\n        dudx = (u[i + 1, j] - u[i - 1, j]) / (2 * Œîx)\n    end\n    if j == 1\n        dvdy = (v[i, j + 1] - v[i, j]) / Œîy\n    elseif j == size(v, 2)\n        dvdy = (v[i, j] - v[i, j - 1]) / Œîy\n    else\n        dvdy = (v[i, j + 1] - v[i, j - 1]) / (2 * Œîy)\n    end\n    return dudx + dvdy\nend\n\n\"\"\"\n    divergens(u, v, Œîx, Œîy)\nBeregner divergensen av vinden med ensidige og sentrale differanser.\n\nArgumenter:\n- u: Matrise med u-komponenten av vinden\n- v: Matrise med v-komponenten av vinden\n- Œîx: Steglengde i x-retningen\n- Œîy: Steglengde i y-retningen\n\nReturnerer:\n- div: Matrise med divergensen av vinden\n\"\"\"\nfunction divergens(u, v, Œîx, Œîy)\n    div = similar(u)\n    I = 1:size(u, 1)\n    J = 1:size(u, 2)\n    for i in I, j in J\n        div[i, j] = punkt_divergens(u, v, i, j, Œîx, Œîy)\n    end\n    return div\nend\n\nN√• kan vi beregne divergensen til hastighetsfeltet.\n\nŒîx = xs[2] - xs[1]\nŒîy = ys[2] - ys[1]\nwind_div = divergens(u, v, Œîx, Œîy)\n\n889√ó744 Matrix{Float32}:\n 1.83983f-5  2.01959f-5   1.77497f-5  ‚Ä¶   6.46355f-6    5.46859f-6\n 2.43273f-5  2.43386f-5   2.01931f-5      4.39634f-6    5.58828f-6\n 2.47338f-5  1.90388f-5   1.6778f-5       7.30273f-6    9.18604f-6\n 2.51377f-5  2.07828f-5   1.4629f-5       3.0613f-6    -2.67876f-6\n 1.75943f-5  1.41999f-5   1.52153f-5      2.00943f-6    6.17037f-7\n 2.13197f-5  1.17784f-5   1.04639f-5  ‚Ä¶   7.54949f-6    7.96339f-6\n 1.60731f-5  1.51459f-5   4.90117f-6      3.89254f-5    4.30663f-5\n 8.11919f-6  1.11851f-5   9.13143f-7      5.29115f-5    5.93644f-5\n 1.0517f-5   1.14041f-5   1.89376f-6      2.8094f-5     2.60035f-5\n 1.50641f-5  7.31389f-6   1.61179f-6      1.12643f-5    1.63356f-5\n ‚ãÆ                                    ‚ã±                \n 7.85493f-6  1.7078f-5    1.75644f-5  ‚Ä¶  -0.000187383  -0.000123478\n 4.70862f-6  7.14492f-6   1.56761f-5     -9.13961f-5    5.74478f-6\n 1.36192f-5  8.53079f-7  -1.53676f-5     -7.85856f-5   -3.08362f-5\n 1.50566f-5  8.07851f-6  -6.70437f-6      2.15464f-5    5.16415f-5\n 1.62689f-5  1.35937f-5   1.01873f-5      1.66683f-5    9.27645f-6\n 1.01798f-5  1.27396f-5   9.91087f-6  ‚Ä¶  -1.5585f-6    -1.62287f-5\n 4.72426f-6  5.37005f-6   3.71983f-6      9.872f-6      1.09482f-5\n 1.08974f-5  7.73772f-6   4.28807f-6      5.4751f-6    -1.35802f-5\n 1.47243f-5  1.45188f-5   6.58732f-6     -9.2442f-6     9.93192f-6\n\n\nVi kan n√• plotte divergensen:\n\nfig = Figure(size = (800, 400))\nax = GeoAxis(fig[1, 1]; limits)\ncf = contourf!(ax, longitudes, latitudes, wind_div, colormap = :curl, levels = 100)\nlines!(ax, GeoMakie.coastlines(50), color = :black)\nColorbar(fig[1, 2], cf, label = \"Divergens (s‚Åª¬π)\")\nfig\n\n\n\n\n\n\nFigur¬†2.4: Divergensen til vindfeltet.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "kapittel5.html#virvling",
    "href": "kapittel5.html#virvling",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "5.6 Virvling",
    "text": "5.6 Virvling\nVirvlingen for vindfeltet er rettet normalt p√• \\(xy\\)-planet og st√∏rrelsen er \\[\nc = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}.\n\\tag{2.1}\\]\nP√• tilsvarende m√•te som divergensen approksimeres de deriverte med differanser av de diskrete verdiene:\n\\[\n\\frac{\\partial v}{\\partial x} \\approx \\frac{v_{i+1,j} - v_{i-1,j}}{\\Delta x}, \\text{ og }\\\\\n\\frac{\\partial u}{\\partial y} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{\\Delta y}\n\\tag{2.2}\\]\nHer definerer vi en funksjon for √• beregne virvlingen numerisk:\n\n\"\"\"\n    punkt_virvling(u, v, i, j, Œîx, Œîy)\nBeregner virvlingen i punktet med indeks (i, j) med ensidige og sentrale differanser.\n\nArgumenter:\n- u: Matrise med u-komponenten av vinden\n- v: Matrise med v-komponenten av vinden\n- i: Indeks i x-retningen\n- j: Indeks i y-retningen\n- Œîx: Steglengde i x-retningen\n- Œîy: Steglengde i y-retningen\n\nReturnerer:\n- virvlingen i punktet (i, j)\n\"\"\"\nfunction punkt_virvling(u, v, i, j, Œîx, Œîy)\n    if i == 1\n        dvdx = (v[i + 1, j] - v[i, j]) / Œîx\n    elseif i == size(u, 1)\n        dvdx = (v[i, j] - v[i - 1, j]) / Œîx\n    else\n        dvdx = (v[i + 1, j] - v[i - 1, j]) / (2 * Œîx)\n    end\n    if j == 1\n        dudy = (u[i, j + 1] - u[i, j]) / Œîy\n    elseif j == size(v, 2)\n        dudy = (u[i, j] - u[i, j - 1]) / Œîy\n    else\n        dudy = (u[i, j + 1] - u[i, j - 1]) / (2 * Œîy)\n    end\n    return dvdx - dudy\nend\n\n\"\"\"\n    virvling(u, v, Œîx, Œîy)\nBeregner virvlingen av vinden med ensidige og sentrale differanser.\n\nArgumenter:\n- u: Matrise med u-komponenten av vinden\n- v: Matrise med v-komponenten av vinden\n- Œîx: Steglengde i x-retningen\n- Œîy: Steglengde i y-retningen\n\nReturnerer:\n- virvling: Matrise med virvlingen av vinden\n\"\"\"\nfunction virvling(u, v, Œîx, Œîy)\n    virvling = similar(u)\n    I = 1:size(u, 1)\n    J = 1:size(u, 2)\n    for i in I, j in J\n        virvling[i, j] = punkt_virvling(u, v, i, j, Œîx, Œîy)\n    end\n    return virvling\nend\n\nN√• kan vi beregne virvlingen til hastighetsfeltet.\n\nwind_curl = virvling(u, v, Œîx, Œîy)\n\n889√ó744 Matrix{Float32}:\n -4.7064f-5   -4.00103f-5  -3.73169f-5  ‚Ä¶  -3.20467f-5   -3.44504f-5\n -4.36382f-5  -3.83372f-5  -4.12759f-5     -2.84282f-5   -3.00125f-5\n -4.26932f-5  -3.87092f-5  -3.94645f-5     -2.80668f-5   -3.26777f-5\n -3.99119f-5  -3.97975f-5  -3.71017f-5     -2.64653f-5   -2.86091f-5\n -4.19907f-5  -3.91131f-5  -3.63212f-5     -3.13197f-5   -2.68424f-5\n -3.27127f-5  -3.47284f-5  -3.81683f-5  ‚Ä¶  -4.09121f-5   -3.69409f-5\n -3.193f-5    -3.98464f-5  -3.48578f-5     -5.95521f-5   -5.4457f-5\n -3.63052f-5  -3.84787f-5  -3.22351f-5     -7.35736f-5   -7.71211f-5\n -3.99177f-5  -3.55319f-5  -3.66838f-5     -4.92478f-5   -4.91211f-5\n -4.01982f-5  -3.49329f-5  -3.3492f-5      -3.07044f-5   -3.00481f-5\n  ‚ãÆ                                     ‚ã±                \n -1.72636f-5  -2.76212f-5  -3.05795f-5  ‚Ä¶  -0.000172363  -5.36797f-5\n -2.50453f-5  -2.86128f-5  -3.96322f-5     -0.000298058  -0.000256035\n -1.99852f-5  -2.25475f-5  -2.30584f-5     -0.000286015  -0.00032936\n -1.07731f-5  -2.18833f-5  -2.00353f-5     -0.000157204  -0.000189765\n -1.06738f-5  -2.20131f-5  -1.76108f-5     -8.76191f-5   -0.000128811\n -1.02326f-5  -1.73569f-5  -1.35183f-5  ‚Ä¶  -7.55898f-5   -7.79094f-5\n -1.01861f-5  -1.13351f-5  -1.87071f-5     -2.13147f-5   -3.10573f-5\n -1.88166f-6  -4.15877f-6  -1.38658f-5     -4.13696f-7   -3.36957f-6\n -3.47157f-6  -1.9466f-6   -4.45137f-6     -1.532f-5     -2.35832f-6\n\n\nVi kan n√• plotte konturlinjer for virvlingen. Her velger vi √• zoome inn p√• et mindre omr√•de s√∏r for Island.\n\nfig = Figure(size = (800, 400))\nax = GeoAxis(fig[1, 1]; limits = ((-26, -10), (59, 67)))\nc = contour!(ax, longitudes, latitudes, wind_curl * Œîx, levels = [1, 5, 10, 15, 20], labels = true)\nlines!(ax, GeoMakie.coastlines(50), color = :black)\n# Colorbar(fig[1, 2], c, label = \"Virvling (s‚Åª¬π)\")\nfig\n\n\n\n\n\n\nFigur¬†2.5: Konturlinjer for virvlingen til vindfeltet, skalert med \\(\\Delta x\\).\n\n\n\n\nVi tar ogs√• med et plot med innfylling av flatene mellom konturlinjene, for √• f√• frem flere detaljer:\n\nfig = Figure(size = (800, 400))\nax = GeoAxis(fig[1, 1]; limits)\ncf = contourf!(ax, longitudes, latitudes, wind_curl, colormap = :ocean, levels = 100)\nlines!(ax, GeoMakie.coastlines(50), color = :black)\nColorbar(fig[1, 2], cf, label = L\"Virvling ($s^{-1}$)\")\nfig\n\n\nKonturlinjer for virvlingen til vindfeltet, skalert med \\(\\Delta x\\), med innfylling av flatene mellom konturlinjene.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "kapittel5.html#tolkninger",
    "href": "kapittel5.html#tolkninger",
    "title": "Kapittel 5: En praktisk anvendelse av \\(\\nabla\\)-operatoren i meteorologi",
    "section": "5.7 Tolkninger",
    "text": "5.7 Tolkninger\nHer refererer vi til kapittel 5.7 i boken, som gjelder uavhengig av programmeringsspr√•k.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Kapittel 5: En praktisk anvendelse av $\\nabla$-operatoren i meteorologi</span>"
    ]
  },
  {
    "objectID": "bibliografi.html",
    "href": "bibliografi.html",
    "title": "Bibliografi",
    "section": "",
    "text": "Gjevik, Bj√∏rn, og Morten Wang Fagerland. u.√•. Feltteori Og Vektoranalyse. 2. utg. Farleia Forlag.\n\n\nTrulsen, Karsten. u.√•. ¬´Python i MEK1100¬ª.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Bibliografi</span>"
    ]
  }
]