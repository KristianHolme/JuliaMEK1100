---
number-offset: [2]
---

# Kapittel 3: Bruk av Julia

## 3.1 Innledning
Vi starter med et lite avsnitt om hvorfor det kan v√¶re en god id√© √• bruke Julia, i stedet for alternativer som Matlab og Python.
I likhet med Matlab er Julia laget for vitenskapelige beregninger, og har mye innebygget funksjonalitet for dette. Sammenlignet med Matlab er Julia mer moderne, det er gratis √• bruke, det er i mange tilfeller raskere enn Matlab, og det er mye enklere √• bruke kode (pakker, funksjoner, etc.) som andre har laget, eller dele din egen kode s√• andre kan bruke den. 

Mange av disse fordelene gjelder ogs√• i sammenligning med Python. Python er i motsetning til Julia ikke laget spesifikt for vitenskapelige beregninger, s√• Julia kan v√¶re mer "ergonomisk" n√•r man skal gj√∏re vitenskapelige beregninger. Det kan ogs√• v√¶re vanskeligere √• f√• relativt enkle programmer til √• kj√∏re raskt, hvis man ikke er en erfaren Python-bruker.

I [dokumentasjonen](https://docs.julialang.org/en/v1/manual/noteworthy-differences/) til Julia kan du lese mer om forskjellene mellom Julia og andre spr√•k (inkludert Python og Matlab).

Kort oppsummert er Julia et godt valg for vitenskapelige beregninger, fordi spr√•ket er (basert p√• forfatterens subjektive mening) enklere √• l√¶re, raskere √• kj√∏re, og morsommere √• skrive enn Python og Matlab. 

Det finnes selvf√∏lgelig flere grunner til √• ikke bruke Julia, feks. 
- Julia er ikke like utbredt som Matlab og Python, s√• det kan v√¶re pakker for spesielle bruksomr√•der som ikke finnes i Julia. (Heldigvis kan man enkelt bruke Python-pakker i Julia, med pakken `PythonCall.jl`)
- Hvis man allerede er komfortabel med Matlab eller Python, og ikke er interessert i √• l√¶re seg et nytt spr√•k.


I dette dokumentet vil vi bruke standard Julia for beregninger, og plotte-biblioteket [Makie.jl](https://docs.makie.org/stable/) for plotting. `Makie.jl` er et moderne bibliotek for datavisualisering og plotting, og er et av de mest popul√¶re plotte-bibliotekene i Julia. 


## 3.2 Litt grunnleggende Julia

#### 3.2.0 Installere Julia
√Ö installere Julia er enkelt. Det kan gj√∏res fra [julialang.org/install/](https://julialang.org/install/). Kort oppsummert: er du p√• en datamaskin med Linux eller macOS, er det bare √• kj√∏re f√∏lgende kommando i terminalen:
```bash
curl -fsSL https://install.julialang.org | sh
```
Dette installerer ogs√• programmet `juliaup` som er et program for √• h√•ndtere ulike versjoner, og oppgradering av Julia. Hvordan man bruker `juliaup` er beskrevet p√• `juliaup` sin github-side: [github.com/JuliaLang/juliaup](https://github.com/JuliaLang/juliaup)

Hvis du bruker Windows kan du g√• til [Microsoft store](https://apps.microsoft.com/detail/9njnww8pvkmn?hl=nb-NO&gl=NO), eller kj√∏re f√∏lgende kommando i kommandolinjen:
```
winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore
``` 

Her vil vi gi en liten introduksjon til hvordan man starter med √• bruke Julia. Det finnes mange andre ressurser p√• internett som kan hjelpe deg med √• komme i gang, f.eks. [denne](https://youtube.com/playlist?list=PLhQ2JMBcfAsiu2BjeDuj0OXxD1Or_FjID&si=eNP1FW-ErIrD5fvA) spillelisten med korte videoer p√• YouTube.

St√•r du fast, vil som regel et kjapt Google-s√∏k eller en LLM-prompt (f.eks. ChatGPT) hjelpe deg. Hvis dette ikke l√∏ser problemet, kan du sp√∏rre forfatteren/oversetteren for hjelp.


### 3.2.1 Oppstart, grensesnitt, kommentarer
P√• samme m√•te som Matlab og Python, brukes Julia hovedsaklig enten i kommandolinjen/terminalen eller i et programmeringsgrensesnitt, eller en kombinasjon av de to. For √• starte Julia i terminalen skriver man `julia` og trykker enter:

```{=html}
<script src="https://asciinema.org/a/6RXHV00mGdkGeZ746Nvx53SVb.js" id="asciicast-6RXHV00mGdkGeZ746Nvx53SVb" async="true"></script>
```

Vi ser at Julia starter med en liten hilsen, og en prompt `julia>`. Deretter kan vi skrive inn en kommando, trykke enter, og f√• svaret.
For √• avslutte Julia, skriver man `exit()` (eller trykker enter) eller gj√∏r tastekombinasjonen `Ctrl+D`.


Programmet som kj√∏rer n√•r vi bruker Julia i kommandolinjen kalles for Julias REPL. Det st√•r for Read-Eval-Print Loop, og det er naturlig nok akkurat det en REPL gj√∏r. Den leser kommandoer, evaluerer dem, og printer ut resultatet. 

#### 3.2.1.1 Hjelpemodus
Julias REPL har flere forskjellige moduser. Den mest nyttige for en nybegynner er hjelpemodusen. Vi kan g√• inn i hjelpemodusen ved √• skrive `?`. Da endres prompten fra `julia>` til `help?>`. I hjelpemodusen kan vi skrive inn navn p√• funksjoner, operatorer, eller andre ting, og f√• en beskrivelse av hva de gj√∏r, og eksempler p√• hvordan de kan brukes. For eksempel:

```{=html}
<script src="https://asciinema.org/a/lC27gGdiynPoZZzHFBjeiEM2e.js" id="asciicast-lC27gGdiynPoZZzHFBjeiEM2e" async="true"></script>
```

For √• g√• ut av hjelpemodusen trykker man tilbaketasten (backspace).

#### 3.2.1.2 Pakkemodus
En annen nyttig modus er pakkemodusen. De som kommer fra en bakgrunn i Python vet kanskje at det kan v√¶re vrient √• h√•ndtere pakker ved √• bruke pip, conda, anaconda, virtuelle milj√∏er, etc. I Julia er det mye enklere. Vi kan g√• inn i pakkemodusen ved √• skrive `]`. Da endres prompten fra `julia>` til `(@1.12) pkg>`. Denne prompten betyr at vi er i grunn-milj√∏et til Julia, med versjon 1.12. I pakkemodusen kan vi gj√∏re mange kommandoer som har med pakker √• gj√∏re. For √• f√• en liste over alle tilgjengelige kommandoer, skriver man `help` (og trykker enter). For eksempel:
```{=html}
<script src="https://asciinema.org/a/DwBmt3gvFSU9SHFYeeB2WgJBx.js" id="asciicast-DwBmt3gvFSU9SHFYeeB2WgJBx" async="true"></script>
```

Her ser vi at vi kan legge til pakker ved √• bruke kommandoen `add`. En pakke som alle burde ha i sitt grunn-milj√∏ er `Revise.jl`. Det er en pakke som gj√∏r at vi slipper √• restarte Julia hver gang vi endrer p√• kode. Her legger vi til Revise.jl:

```{=html}
<script src="https://asciinema.org/a/MgGkAZWtoDBE0t9WtoNE8Hfiu.js" id="asciicast-MgGkAZWtoDBE0t9WtoNE8Hfiu" async="true"></script>
```
::: {.callout-note collapse="true"}
Her brukte vi argumentet `--startup-file no` fordi vi har konfigurert Julias startup-fil til √• aktivere Revise.jl automatisk. Men her hadde vi ikke installert `Revise.jl`, s√• vi la til dette argumentet for √• unng√• feilmelding.
:::

Avhengig av hvor mange andre pakker vi har i milj√∏et, kan det ta noen sekunder √• installere pakker. N√•r vi installerer pakker blir koden til pakkene lasted ned og prekompilert.

Det kan v√¶re lurt √• sette opp maskinen sin slik at [Revise.jl](https://timholy.github.io/Revise.jl/stable/) automatisk aktiveres n√•r du starter Julia. Det kan du lese mer om her: [Revise.jl config](https://timholy.github.io/Revise.jl/stable/config/).

N√•r vi bruker Julia i forskjellige prosjekter, l√∏nner det seg bruke spesifikke milj√∏er for hvert prosjekt. Hvis vi har en mappe som heter `MEK1100` der vi har all koden vi skriver for dette faget, lager vi et eget milj√∏ for denne mappen ved √• navigere til mappen i terminalen, starte Julia, g√• inn i pakkemodusen og skrive `activate .` (punktumet skal v√¶re med!). Da endres prompten fra `(@v1.12) pkg>` til `(@MEK1100) pkg>`. Denne prompten betyr at vi er i milj√∏et for prosjektet `MEK1100`.

N√• er vi i milj√∏et for prosjektet `MEK1100`. Her kan vi legge til de pakkene vi trenger for dette emnet. I dette milj√∏et har vi ogs√• tilgang til alle pakkene vi har i grunnmilj√∏et. N√•r vi legger til pakker i et milj√∏, vil det bli opprettet en fil som heter `Project.toml` i mappen. Denne filen inneholder informasjon om pakkene vi har i milj√∏et, og versjonene av pakkene. Dette gj√∏r det enkelt √• bruke andres kode; du laster ned mappen med kode (inkludert `Project.toml`-filen), gj√∏r pakke-kommandoen `activate .` og deretter `instantiate`. `instantiate`-kommandoen henter alle pakkene i `Project.toml`-filen og installerer de. Du kan da kj√∏re koden i mappen.

N√•r vi skal bruke Makie.jl til plotting m√• vi velge hvilken backend vi skal bruke. Her har man flere alternativer, men enkelt sagt er det to alternativer som er mest popul√¶re. Hvis vi √∏nsker h√∏yoppl√∏ste plots vi kan eksportere som vektorgrafikk (f.eks. for √• inkludere i en rapport), bruker vi pakken `CairoMakie.jl`. Hvis vi er interessert i interaktivitet (zoom, rotasjon, knapper, etc.) bruker vi pakken `GLMakie.jl`. N√• legger vi til begge pakkene i MEK1100-milj√∏et:

```{=html}
<script src="https://asciinema.org/a/CAVa7erLnqDUqdV41E9tgYzaX.js" id="asciicast-CAVa7erLnqDUqdV41E9tgYzaX" async="true"></script>
```
√Ö legge til disse pakkene kan ta litt tid, ettersom de har mye kode som skal prekompileres (jeg hadde allerede pakkene prekompilert n√•r jeg tok dette opptaket).

##### 3.2.1.2.* Hvorfor Julia er raskere enn Matlab og Python
I motsetning til Matlab og Python, bruker Julia en s√•kalt "just-in-time"-kompilator, som kompilerer koden til maskinkode rett f√∏r den kj√∏res, i stedet for √• kompilere koden til maskinkode n√•r den installeres.
N√•r dette gj√∏res spesialiseres funksjonene for de input-argumentene du bruker. Disse to tingene: spesialisering og kompilering, er det som gj√∏r Julia raskere enn Matlab og Python, nesten like raskt som C. Ulempen med dette er det kan ta litt tid √• kj√∏re en funksjon for f√∏rste gang, fordi koden du skal kj√∏re m√• spesialiseres og kompileres. Men neste gang du kj√∏rer funksjonen vil den kj√∏re raskt, siden koden allerede er spesialisert og kompilert. Prekompilering er n√•r Julia gjetter p√• hvordan du kommer til √• bruke noen funksjoner i en pakke, og kompilerer koden til maskinkode p√• forh√•nd. Dette skjer som sagt ofte n√•r vi laster ned pakker, eller oppdaterer pakker. 

#### 3.2.1.3 Julia i VS Code
Det er vel og bra √• kun bruke Julia i terminalen, men som oftest er det enklere √• bruke Julia i et programmeringsgrensesnitt (engelsk: IDE - Integrated Development Environment). Det mest popul√¶re grensesnittet for Julia er VS Code, som er et gratis programmeringsgrensesnitt. Det kan lastes ned fra nettsiden [code.visualstudio.com](https://code.visualstudio.com/).

N√•r man har installert VS Code, er det neste man m√• gj√∏re √• installere [utvidelsen for Julia](https://www.julia-vscode.org/docs/stable/gettingstarted/).

N√•r vi har Julia-utvidelsen, kan vi starte VS Code, √•pne mappen vi skal lagre filene v√•re i (f.eks. MEK1100-mappen). Deretter kan vi starte med √• lage et script. Da kan vi lage en mappe som heter `scripts`, og der opprette en fil som heter `script.jl`. Da kan vi skrive inn koden v√•r i filen.

N√•r vi har √•pnet filen i VS Code, kan vi starte opp Julia i VS Code med √• trykke `alt + j + o`. Da f√•r vi opp en Julia-REPL, som er koblet til filene v√•re. Det betyr at vi kan skrive en linje i filen v√•r, trykke `ctrl + enter`. S√• vil den linjen kj√∏res i v√•r REPL. 

Her f√∏lger et opptak der vi demonstrerer hvordan vi kan bruke Julia i VS Code. Vi √•pner MEK1100-mappen og starter Julia med `alt + j + o`. Vi √•pner en fil som inneholder kode for √• visualisere en funksjon. Deretter kj√∏rer vi filen linje for linje med `shift + enter` (dette gj√∏r det samme som `ctrl + enter` i tillegg til √• hoppe til neste linje). Resultatene av hver linje vises ved siden av linjen, og i v√•r REPL. Plottet vises i en ny fane i VS Code.

![julia_vs_code](screen_recs/julia-vscode-demo.mp4)




#### 3.2.1.3 Numerikk {#sec-numerikk}
Numerikk i Julia gj√∏res med `Array`-er. I Julia er et `Array` en liste med elementer. Det kan v√¶re en liste med tall, en liste med strenger, en liste med funksjoner, osv. Vi kan ogs√• ha `Array`er i flere dimensjoner. Et √©n-dimensjonalt `Array` kalles ofte for en `Vector`, og et to-dimensjonalt `Array` kalles ofte for en `Matrix`. Vi kan lage en `Array` med klammeparenteser. Her skriver vi inn koden i filen v√•r, og trykker `ctrl + enter`. Da vil resultatet vises ved siden av linjen, og printes i REPL-en.

```{julia}
#| echo: true
a = [1.2, 3.0, 4.2, 2.8]
```
Her f√•r vi at resultatet er en vector, som er det samme som en 1-dimensjonal array. Vi kan ogs√• lage en array med `zeros(n)`, `ones(n)`, `rand(n)`, `randn(n)`, etc. (Du kan jo bruke hjelpemodusen for √• finne ut hva rand og randn gj√∏r!). For eksempel:
```{julia}
#| echo: true
zeros(3)
```

Vi kan ogs√• lage en 2-dimensjonal array med `zeros(m, n)`, `ones(m, n)`, `rand(m, n)`, `randn(m, n)`, etc. For eksempel:
```{julia}
#| echo: true
b = rand(2,4)
```

For √• prosessere data i arrays eller vectorer trenger vi funksjoner. I funksjoner kan vi lage funksjoner p√• flere m√•ter. Har vi en kort funksjon kan vi skrive den slik:

```{julia}
#| echo: true
f(x) = 3x + sin(2x)
```

Hvis funksjonen er mer komplisert kan vi skrive den slik:

```{julia}
#| echo: true
function g(x)
    p = x + 1
    q = 2x - p
    return q^2
end
```

Vi kan bruke funksjonene slik: 
```{julia}
#| echo: true
a = 5.9
ga = g(a)
fa = f(a)
println("g(a) = $(round(ga,digits=2)), f(a) = $(round(fa,digits=2))")
```

Hvis vi vil anvende en funksjon p√• alle elementene i en array/vektor, kan vi bruke "broadcasting". Det gj√∏res ved √• skrive et punktum mellom funksjonsnavnet of argumentene: 
```{julia}
#| echo: true
w = [1.2, 3.0, 4.2, 2.8]
g.(w)
```

Dette fungerer ogs√• for funksjoner som har flere variabler. For eksempel:
```{julia}
#| echo: true
h(x, y) = x + 1000y
u = [1.2, 3.0, 4.2, 2.8]
w = [9.8, 4.1, 5.7, 8.7]
h.(u, w)
```
Her anvender vi funksjonen `h` parvis p√• elementene i vektorene `u` og `w`.
Hvis vi vil anvende funksjonen p√• alle kombinasjoner av elementer i vektorene `u` og `w`, kan vi transponere den ene vektoren, s√• den blir en radvektor:
```{julia}
#| echo: true
w'
```
Her ser vi at `w'` er en radvektor. Apostrof er tegnet for transponering i Julia. Vi kan s√• anvende funksjonen `h` p√• alle kombinasjoner av elementer i vektorene `u` og `w`:
```{julia}
#| echo: true
M = h.(u, w')
```
Her ser vi at et element $M_{i,j}$ er $h(u[i], w[j])$ for $i = 1:4$ og $j = 1:4$.

#### 3.2.1.4 Plotting
N√• skal vi se kjapt p√• hvordan vi kan plotte data med `Makie.jl`. Her importerer vi f√∏rst `CairoMakie.jl`, lager noen punkter, og plotter dem. 

```{julia}
#| echo: false
#| eval: true
#| include: false
using CairoMakie
set_theme!(theme_latexfonts())
update_theme!(fontsize=15)
```

```{julia}
#| echo: true
using CairoMakie
x = 0:0.1:2œÄ
y = sin.(x)
lines(x, y)
```
Her brukte vi funksjonen `lines` som plottet linjen mellom punktene i vektorene `x` og `y`. Ofte vil vi ha litt mer kontroll over figurene vi lager, og da kan vi bruke funksjonen `Figure` og `Axis`, for √• f√∏rst lage en figur, s√• plassere en akse i figuren, og s√• plotte forskjellige ting i aksen:

```{julia}
#| echo: true
t = 0:0.1:2œÄ
y = sin.(t)
random_point_t = rand() .* 2œÄ
random_point_y = sin(random_point_t)

fig = Figure()
ax = Axis(fig[1, 1])
lines!(ax, x, y, label="sin(x)")
scatter!(ax, random_point_t, random_point_y, label="Tilfeldig punkt", markersize=16, color= :green)
vlines!(ax, random_point_t, color=:red, linestyle=:dash)
hlines!(ax, random_point_y, color=:red, linestyle=:dash)
axislegend(ax)
fig
```

Her har vi brukt flere forskjellige plottefunksjoner fra `Makie.jl`. Bruk hjelpemodusen for √• finne ut hva de gj√∏r! Vi legger merke til at `lines!`-funksjonen vi brukte her sluttet med et utropstegn. Dette er en konvensjon som indikerer at funksjonen endrer p√• noen av argumentene. Her endrer vi p√• aksen, ved √• plotte en linje. Ellers er `lines!`-funksjonen og `lines`-funksjonen like. Vi kan ogs√• se at vi bruker `axislegend`-funksjonen til √• legge til en beskrivelse av de forskjellige plottene. 

Hvis vi vil lagre figuren v√•r til en fil, kan vi bruke funksjonen `save`. For eksempel:
```{julia}
#| echo: true
filnavn = joinpath("figurer", "sin_plot.png")
mkpath("figurer")
save(filnavn, fig)
```
Her har vi brukt funksjonen `joinpath` til √• lage en filsti til en mappe som heter `figurer`, og en fil som heter `sin_plot.png`. Vi har ogs√• brukt funksjonen `mkpath` til √• lage mappen hvis den ikke finnes.

#### 3.2.1.5 Emojier og symboler
I Julia kan vi bruke emojier og matte-symboler direkte i koden v√•r. For eksempel:

```{=html}
<script src="https://asciinema.org/a/fg5BS7lV8bETbBYBQdlFKZxjy.js" id="asciicast-fg5BS7lV8bETbBYBQdlFKZxjy" async="true"></script>
```
For √• f√• $\LaTeX$-symboler, kan vi bruke `\` f√∏r symbolet, slik som `\pi` for $\pi$, deretter trykker vi`tab` for √• gj√∏re om `\pi` til $\pi$. For emojier bruker vi en kolon f√∏r symbolet, slik som `\:smile:` for üòÑ, og trykker `tab` for √• gj√∏re om `\:smile:` til üòÑ. Er du usikker p√• hva en emoji heter, kan du trykke `tab` f√∏r du har skrevet ferdig navnet, f.eks. `\:smil` + `tab` for √• f√• opp alle emojiene der navnet begynner p√• `smil`.

I tillegg til de vanlige variabeltypene (string, skalar, vektor, osv...) har Julia ogs√• en type som heter `Symbol`. Et `Symbol` er litt som en string, og er mye brukt i Julia. Man lager et `Symbol` ved √• bruke `:` f√∏r teksten. For eksempel:
```{julia}
#| echo: true
a = :hei
typeof(a)
```

Her er `a` av typen `Symbol`.

### 3.2.2 Matriser
I to av eksemplene overfor lagde vi en matrise ved √• bruke `rand(m, n)`, og ved √• bruke broadcasting av en funksjon over en kolonnevektor og en radvektor. Vi kan ogs√• lage matriser ved √• skrive inn elementene direkte i en array:
```{julia}
#| echo: true
A = [
    1 3 0
    2 0 4
    1 3 1
]
```
Som nevnt tidligere kan vi transponere matrisen ved √• skrive en apostrof etter matrisen:
```{julia}
#| echo: true
A'
```
Vi kan gj√∏re flere ting med matriser, for eksempel kan vi finne den inverse matrisen ved √• skrive `inv(A)`. For √• gj√∏re dette m√• vi benytte oss av det innebygde biblioteket `LinearAlgebra`.
```{julia}
#| echo: true
using LinearAlgebra
A_inv = inv(A)
```

N√• kan vi sjekke om dette virkelig er den inverse matrisen ved √• gange de sammen:
```{julia}
#| echo: true
A_inv * A
```
Vi ser at resultatet er enhetsmatrisen, s√• vi ser at dette virkelig er den inverse matrisen.

Vi kan ogs√• finne determinanten av en matrise ved √• skrive `det(A)`.
```{julia}
#| echo: true
det(A)
```
Og vi kan finne summen av alle elementene i matrisen ved √• skrive `sum(A)`.
```{julia}
#| echo: true
sum(A)
```
Hvis vi kun vil summere over radene, eller kun kolonnene, kan vi bruke funksjonen `sum` med argumentet `dims=1` eller `dims=2`. For eksempel:
```{julia}
#| echo: true
sum_kolonner = sum(A, dims=1)
sum_rader = sum(A, dims=2)
@show sum_kolonner sum_rader
```

I Julia bruker matriser samme notasjon som i matematikk, dvs. $A_{i,j}$ er elementet i rad $i$ og kolonne $j$ i matrisen $A$. (i motsetning til Python, der matriser har indeksering som starter p√• 0. for det f√∏rste elementet.)

```{julia}
#| echo: true
A[2, 1] + A[3, 2]
```

Funksjonen `size` returnerer antall rader og kolonner i matrisen.
```{julia}
#| echo: true
size(A)
```
Hvis vi vil ha det totale antallet elementer i matrisen, kan vi bruke funksjonen `length`.
```{julia}
#| echo: true
length(A)
```

Hvis vi vil lage oss en diagonalmatrise, kan vi bruke funksjonen `diagm`.
```{julia}
#| echo: true
diagm([1, 2, 3])
```
Hvis vi vil lage oss en enhetsmatrise, kan vi bruke funksjonen `eye`.
 
### 3.2.3 Kolon-operatoren og LinRange
Hvis vi vil generere en vektor med `n` elementer fra `a` til `b`, med jevne mellomrom, kan vi bruke `LinRange`-funksjonen:

```{julia}
#| echo: true
u = LinRange(-15, 15, 11)
```
For √• indeksere flere elementer i en vektor eller matrise, kan vi bruke kolon-operatoren. Hvis vi vil ha element 3 til og med 5 i vektoren over indekserer vi med `u[3:5]`.
```{julia}
#| echo: true
u[3:5]
```
Hvis vi vil hvert tredje element fra og med element 4 og til slutten av vektoren, kan vi indeksere med  `u[4:3:end]`. 3-tallet betyr at vi starter p√• element 4, og g√•r med 3 steg helt til vi kommer til det siste elementet i indekseringer (her bruker vi `end` som betyr siste indeks).
```{julia}
#| echo: true
u[4:3:end]
```

Kolon-indeksering fungerer alts√• veldig likt som i matlab, men ganske forskjellige fra Python. I Python tar man ikke med slutt-indeksen, og steglengden er det siste tallet i indekseringen (hvis man i Python indekserer med 1:12:2 betyr det at man starter p√• det andre elementer, og g√•r med 2 steg helt til element nummer 13.) Her er noen flere eksempler:

```{julia}
#| echo: true
A = [
  1 2 3 4
  5 6 7 8
  0 10 11 12
  13 14 15 16
]
```
```{julia}
#| echo: true
A[2:3, :]
```

F√∏rste til tredje rad, andre til fjerde kolonne:
```{julia}
#| echo: true
A[1:3, 2:4]
```
Andre og tredje rad, alle kolonnene:
```{julia}
#| echo: true
A[2:3, :]
```
Steglengde 2 langs kolonnene:
```{julia}
#| echo: true
A[2:3, 2:2:4]
```
Steglengde 3 langs kolonnene:
```{julia}
#| echo: true
A[2:3, 1:3:4]
```




### 3.2.4 jl-filer og funksjoner
Som nevnt tidligere kan vi skrive kode i filer (som alle skal slutte p√• `.jl`). N√•r vi skriver Julia-kode, er det mest vanlig √• kj√∏re kode i filen linje-for-linje, litt som i en Jupyter-notebook. Vi kan ogs√• kj√∏re koden i en fil uten √• f√∏rst √•pne en REPL. Her har vi et eksempel p√• en jl-fil der vi lager en matrise, og printer ut litt informasjon om den. 
```{julia}
#| echo: true
A = [
  1 3 0
  2 1 1
]
println(A)
println(length(A))
println(size(A))
println(diag(A))
println(sum(A))
println(A')
```
Hvis vi legger denne koden i en fil som heter `MatriseEksempel.jl`, kan vi kj√∏re ved √• skrive `julia MatriseEksempel.jl` i terminalen.

Her lager vi et litt mer komplekst eksempel, der vi lager en funksjon for √• lage tridiagonale matriser.
```julia
using LinearAlgebra
"""
  tridiag(n)
Lager en nxn-matrise med -2 p√• diagonalen og 1 p√• de to subdiagonalene.
"""
function tridiag(n)
  identity_matrix = I(n)
  upper_subdiagonal = Bidiagonal(zeros(n), ones(n-1), :U)
  lower_subdiagonal = Bidiagonal(ones(n-1), zeros(n), :L)
  A = identity_matrix + upper_subdiagonal + lower_subdiagonal
  return A
end
```
Vi legger denne filen i mappen `diverse_filer`. Hvis vi vil kj√∏re koden fra denne funksjonen, kan vi i en REPL skrive `include("diverse_filer/tridiag.jl")` og s√• `tridiag(5)`:

```{julia}
#| echo: true
include("diverse_filer/tridiag.jl")
tridiag(5)
```
Vi kan ogs√• bruke hjelpemodusen for √• finne ut hva funksjonen gj√∏r. Hjelpemodusen bruker beskrivelsen vi skrev i `docstring`-en til funksjonen (teksten mellom `"""` og `"""`).

```julia
help?> tridiag
search: tridiag diag isdiag Tridiagonal

  tridiag(n) Lager en nxn-matrise med -2 p√• diagonalen og 1
  p√• de to subdiagonalene.
```

### 3.2.5 Enkel plotting i 2D
`Makie.jl` har flere funksjoner for √• plotte data i 2D, noen av de har vi vist tidligere. Her kopierer vi eksempelet fra boken, og fra Python-oversettelsen:

```{julia}
#| echo: true
x = LinRange(-2œÄ, 2œÄ, 41)
y = x .^ 3
lines(x, y)
```
Her har vi brukt broadcasting p√• `^`-operatoren, som i likhet med matematisk notasjon betyr "opph√∏yd i". Siden vi vil at dette skal gj√∏res med alle elementene i vektoren `x`, bruker vi `.`-operatoren.
Vi valgte her √• diskretisere $x$-intervallet med 41 punkter som gir steg p√• $\frac{4\pi}{40} = \frac{\pi}{10}$. Velges dette steget for lite blir grafen hakkete. Pr√∏v f.eks. med et steg p√• $\pi/2$.

Vi kan ogs√• plotte funksjoner som er gitt ved en parametrisering. En sirkel med radius r kan uttrykkes med $x(t) = r \cos(t)$ og $y(t) = r \sin(t)$, der $t$ g√•r fra 0 til $2\pi$. Vi plotter en sirkel med radius 3:
```{julia}
#| echo: true
t = LinRange(0, 2œÄ, 101)
x = 3 * cos.(t)
y = 3 * sin.(t)
fig = Figure()
ax = Axis(fig[1, 1], aspect = DataAspect())
lines!(ax, x, y)
fig
```
Her har vi brukt broadcasting p√• `cos` og `sin`-funksjonene, som i likhet med matematisk notasjon betyr "cosinus" og "sinus". Siden vi vil at dette skal gj√∏res med alle elementene i vektoren `t`, bruker vi `.`-operatoren. Vi bruker ogs√• `.`-operatoren n√•r vi ganger med 3. Vi har ogs√• satt `aspect = DataAspect()` for at aksene skal ha samme skalering. Hvis vi ikke gj√∏r dette, kan aksene bli forskjellige skalerte, og da ville grafen se ut som en ellipse.

### 3.2.6 Punktum foran en operasjon
Noen tegn/operasjoner (f.eks. `*`, `/`, og `^`) brukes til to forskjellige matematiske funksjoner. N√•r variablene disse operasjonene virker p√• er skalarer, vil den vanlige betydning (multiplikasjon og divisjon) gjelde slik at f.eks `3*2`vil gi det forventede svaret `6`. Hvis variablene derimot er enten vektorer eller matriser, vil operasjonene betegne de tilsvarende matriseoperasjonene. Lar vi `A`og `B` v√¶re to matriser, vil `A*B` v√¶re matrisemultiplikasjon av `A` og `B`:

```{julia}
#| echo: true
A = [1 2; 3 4]
B = [5 6; 7 8]
A * B
```
√ònsker vi derimot at hvert element i `A` skal multipliseres med det tilsvarende elementet i `B`, bruker vi broadcasting-operatoren `.` foran operasjonen, som vi var inne p√• i Seksjon @sec-numerikk:

```{julia}
#| echo: true
A .* B
```

I eksempelet over der vi √∏nsket √• regne ut $y=x^3$ og vi allerede har definert en vektor med $x$-verdier, vil vi at hvert element i $x$ skal opph√∏yes i tredje; vi √∏nsker _ikke_ √• bruke matrisemultiplikasjon av $x$ med seg selv to ganger. Merk at dersom du √∏nsker √• multiplisere eller dividere en vektor eller en matrise med en skalar, beh√∏ver man ikke bruke broadcasting-operatoren `.` foran operasjonen. Her f√∏lger noen eksempler:

```{julia}
#| echo: true
A .*2
```
```{julia}
#| echo: true
A * 2
```

```{julia}
#| echo: true
a = collect(1:4)
println(a)
println(a .* 2)
println(a * 2)
try
    a * a
catch e
    io = IOBuffer()
    showerror(io, e)
    error_msg = String(take!(io))
    @warn "Det fungerer ikke √• gange en kolonnevektor med seg selv:\n$(error_msg)"
end
@info "Vi kan gange en radvektor (a') med en kolonnevektor (a):"
@show a' * a
```

Her brukte vi flere nye funksjoner, men frykt ikke! Hjelpemodusen er din venn!

```{julia}
#| echo: true
try
    a^2
catch e
    io = IOBuffer()
    showerror(io, e)
    error_msg = String(take!(io))
    @warn "Det fungerer ikke √• opph√∏ye en kolonnevektor i andre (samme som √• gange med seg selv):\n$(error_msg)"
end
```



Broadcasting kan ogs√• brukes p√• vilk√•rlige funksjoner som er definert for en enkelt type, men i situasjoner der man vil anvende funksjoner elementvis p√• en vektorer av den typen. I det f√∏lgende eksempelet bruker vi funksjonen `reverse` elementvis p√• en vektor med strenger:

```{julia}
#| echo: true
@show reverse("akebakke")
ordliste = ["eple", "tastatur", "st√∏vsuger"]
reverse.(ordliste)

```

## 3.3 Plotting av flater
Vi skal n√• se p√• hvordan vi kan lage plottet av flaten i figur 1.7 (og 3.1) i boken. Dette er den samme flaten som vi har studert p√• side 18 i kapittel 1 og er gitt matematisk ved formelen
$$
h = \frac{h_0}{1 + \frac{x^2 + y^2}{R^2}}
$${#eq-Beerenberg}

Formelen modellerer en isolert fjelltopp der $h$ er h√∏yden over havflaten, $h_0$ er h√∏yden p√• toppen av fjellet, og $R$ er et m√•l for radius i fjellet. Konstantene $h_0$ og $R$  er satt til $2277$m og $4000$m.

Det kan v√¶re lurt √• de p√•f√∏lgende kommandoene i en REPL (eller linje for linje i en jl-fil) for √• f√• en bedre oversikt over hva som skjer. 
```{julia}
#| echo: false
#| eval: false
using Colors
using GLMakie
GLMakie.activate!()
h0 = 2277
R = 4000
km = 1000
h(x, y) = h0 / (1 + (x^2 + y^2) / R^2)

nx = 41
ny = 41
x = LinRange(-10km, 10km, nx)
y = LinRange(-10km, 10km, ny)
z = h.(x, y')

custom_blue = RGB(0.35, 0.67, 0.93)
color_matrix = fill(custom_blue, nx, ny)

fig = Figure()
ax = Axis3(fig[1, 1], xlabel="x [km]", ylabel="y [km]", zlabel="h [m]",
    azimuth=0.3œÄ, elevation=œÄ / 6)
surface!(ax, x ./ km, y ./ km, z, color=color_matrix)
wireframe!(ax, x ./ km, y ./ km, z, color=:black)
save("julia_mek1100/figurer/3_1_beerenberg.png", fig)
```
![En modell av fjelltoppen Beerenberg p√• Jan Mayen](figurer/3_1_beerenberg.png)

F√∏r vi starter, importerer vi pakkene vi trenger. Siden vi skal lage et 3D-plot, bruker vi `GLMakie.jl`. For √• spesifisere samme farger som i boken, bruker vi `Colors.jl`.

```julia
using GLMakie
using Colors
```

F√∏rst definerer vi konstantene v√•re $h_0$ og $R$. Vi definerer ogs√• en konstant for √• konvertere kilometer til meter.

```julia
h0 = 2277
R = 4000
km = 1000
```

N√• definerer vi h√∏yde-funksjonen $h(x, y)$.
```julia
h(x, y) = h0 / (1 + (x^2 + y^2) / R^2)
```

$x$- og $y$-aksen skal spenne over et omr√•de p√• $20\times 20$ km med sentrum i origo. I motsetning til i Matlab og Python, trenger vi ikke √• lage et "meshgrid", vi trenger bare $x$-verdiene og $y$-verdiene til punktene v√•re. Vi definerer konstanter for antallet punkter i $x$- og $y$-retningen, og lager vektorer for $x$- og $y$-verdiene.
```julia
nx = 41
ny = 41
x = LinRange(-10km, 10km, nx)
y = LinRange(-10km, 10km, ny)
```

Antallet punkter i hver retning m√• tilpasses for hvert eksempel, her har vi brukt 41 punkter i hver retning, som er passelig for √• unng√• at flaten blir for hakkete. 

Vi lager en matrise med h√∏ydene for alle kobinasjoner av $x$- og $y$-verdiene.
```{julia}
#| echo: true
z = h.(x, y')
```

For √• oppn√• n√∏yaktig samme farger som i boken, lager vi en matrise med farger for hvert punkt. Her blir `color_matrix` en matrise med `nx` rader og `ny` kolonner, der hvert element er `custom_blue`-fargen.
```julia
custom_blue = RGB(0.35, 0.67, 0.93)
color_matrix = fill(custom_blue, nx, ny)
```

Vi lager en figur og plasserer en 3D-akse i figuren.
```julia
fig = Figure()
ax = Axis3(fig[1, 1], xlabel="x [km]", ylabel="y [km]", zlabel="h [m]")
```
N√• er vi klare for √• plotte flaten! Her trenger vi to typer plotter: `surface` for √• plotte flaten, og `wireframe` for √• plotte rutenettet.

```julia
surface!(ax, x ./ km, y ./ km, z, color=color_matrix)
wireframe!(ax, x ./ km, y ./ km, z, color=:black)
fig
```

Her har vi brukt `./`-operatoren for √• dele hvert element i `x` og `y` med `km` for √• konvertere til kilometer.

Det er mange muligheter for √• justere og pynte p√• plottene v√•re med `Makie.jl`. Har du lyst p√• litt inspirasjon, anbefales det √• se p√• [Beautiful Makie](https://beautiful.makie.org/dev/), og bla litt i [dokumentasjonen](https://docs.makie.org/stable/) til `Makie.jl`. Her tar vi med et eksempel p√• litt mer avansert bruk av `Makie.jl`.


## 3.4 Plotting av konturlinjer {#sec-konturlinjer}
Vi skal ta for oss et nytt eksempel fra kapittel 1, side 10; lufttrykket ved havoverflaten i tilknytning til et stormsenter. Formelen vi skal bruke er gitt ved

$$
p = p_0 - \frac{\Delta p}{1 + \frac{x^2 + y^2}{R^2}}
$${#eq-Lufttrykk}

der $p_0$ er lufttrykket langt borte fra sentrum, $\Delta p$ er trykkfallet inn mot sentrum og $R$ er et m√•l for utstrekningen av lavtrykker. Konturlinjene vi skal plotte er gjengitt i @fig-lufttrykk-kontur. 

```{julia}
#| label: fig-lufttrykk-kontur
#| fig-cap: "Til venstre: konturlinjer for konstant trykk (isobarer) rundt et lavtrykkssentrum. Til h√∏yre: kontinuerlige farger for trykk."
#| echo: false
using CairoMakie
CairoMakie.activate!()

R = 50
p0 = 1000
dp = 40

x = LinRange(-150, 0, 151)
y = LinRange(0, 150, 151)
p(x, y) = p0 - dp / (1 + (x^2 + y^2) / R^2)

p_values = p.(x, y')

cmap = :viridis

fig = Figure(size=(680, 340))
ax_contour = Axis(fig[1,1], xlabel="x [km]", ylabel="y [km]", aspect=DataAspect())
contour!(ax_contour, x, y, p_values, levels=[970, 975, 980, 985, 990, 995],labels=true, linewidth=2, colormap=cmap, labelsize=15)
ax_contourf = Axis(fig[1,2], xlabel="x [km]", ylabel="y [km]", aspect=DataAspect())
cf = contourf!(ax_contourf, x, y, p_values, colormap=cmap, levels=100)
Colorbar(fig[1,3], cf)
fig
```

Vi starter med konstantene som skal oppgis i km ($R$) og hPa ($p_0$ og $\Delta p$).
```julia
R = 50
p0 = 1000
dp = 40
```

Vi lager en funksjon for trykket $p(x, y)$.
```julia
p(x, y) = p0 - dp / (1 + (x^2 + y^2) / R^2)
```

Til forskjell fra boka skal vi her la $x$-aksen v√¶re definert over et omr√•de fra -150 til 0 km, og $y$-aksen v√¶re definert over et omr√•de fra 0 til 150 km, deretter regner vi ut p-verdiene for alle kobinasjoner av $x$- og $y$-verdiene.
```julia
x = LinRange(-150, 0, 151)
y = LinRange(0, 150, 151)
p_values = p.(x, y')
```

Vi lager en figur og plasserer en 2D-akse i figuren.
```julia
fig = Figure()
ax_contour = Axis(fig[1,1], xlabel="x [km]", ylabel="y [km]", aspect=DataAspect())
``` 
N√• plotter vi konturer med funksjonen `contour!`.

```julia
contour!(ax_contour, x, y, p_values, levels=[970, 975, 980, 985, 990, 995], 
  labels=true, linewidth=2, labelsize=15
)
```
Her har vi spesifisert at vi vil ha konturlinjer for trykkene 970, 975, 980, 985, 990 og 995 hPa. Vi har ogs√• spesifisert at vi vil ha "labels" (tekst p√• konturlinjene). Hvis vi vil ha andre farger kan vi bruke argumentet `colormap`. F.eks. `colormap=:plasma`, eller `colormap=:jet` (`:jet` er samme colormap som i Python-oversettelsen). For en liste over alle tilgjengelige colormaps, se [Makie.jl colormaps](https://docs.makie.org/dev/explanations/colors#Colormaps).

N√• vil vi lage plottet til h√∏yre i @fig-lufttrykk-kontur. Her bruker vi funksjonen `contourf!` for √• fylle inn flatene mellom konturlinjene. F√∏rst lager vi en ny akse og plasserer den i figuren.

```julia
ax_contourf = Axis(fig[1,2], xlabel="x [km]", ylabel="y [km]", aspect=DataAspect())
```

S√• plotter vi fyltene med funksjonen `contourf!`.

```julia
cf = contourf!(ax_contourf, x, y, p_values, colormap=cmap, levels=100)
```

Her har vi spesifisert at vi vil ha 100 forskjellige konturniv√•er.
For √• legge til en fargebar, bruker vi funksjonen `Colorbar`. Vi lagrer ogs√• plotteobjektet i variabelen `cf` for √• kunne bruke det i funksjonen `Colorbar`.
```julia
Colorbar(fig[1,3], cf)
fig
```

Her har vi plassert fargebaren i figuren, og vi har brukt `fig[1,3]` for √• plassere den til h√∏yre for aksene. N√•r vi plasserer akser, fargebarer, og andre ting i figurer, kan vi bruke indeksering som ligner p√• matrise-indeksering. F.eks. `fig[1,3]` betyr plassering i rad 1, kolonne 3 i figuren.

## 3.5 Plotting av vektorfelt og beregning av gradientvektor
En vektor i kartesiske koordinater $\mathbf v = v_x(x,y)\mathbf i + v_y(x,y)\mathbf j$ kan plottes med funksjonen [arrows2d](https://docs.makie.org/dev/reference/plots/arrows).

`arrows2d` kan brukes p√• flere m√•ter (ta gjerne en kikk p√• dokumentasjonen). Her bruker vi den enkleste. Da trenger vi √• spesifisere punkter (gitt ved x og y-vektorer), og en funksjon som for ethvert punkt returnerer en vektor (gitt ved en x og y-komponent).

La oss ta et eksempel:
$$
\mathbf v = (x^2 + 2y - \frac{1}{2}xy)\mathbf i - 3y\mathbf j
$$

Vi lar $x$ og $y$ variere mellom $-5$ og $5$. Vi passer p√• √• bruke st√∏rre avstand mellom punktene for at vektorene ikke skal overlappe hverandre. 

```{julia}
x = LinRange(-5, 5, 11)
y = LinRange(-5, 5, 11)
``` 

S√• definerer vi vektorfeltet.
```{julia}
function v(point)
    x = point[1]
    y = point[2]
    return [(x^2 + 2y - 0.5x*y), -3y]
end
```
N√• kan vi plotte vektorfeltet.
```{julia}
arrows2d(x, y, v, lengthscale=0.04)
``` 
Her har vi skalert ned vektorene for at de ikke skal overlappe hverandre.


N√• skal vi plotte gradientvektorer. Hvis vi har definert en en funksjon som er et skalarfelt i Julia, kan vi beregne gradienten med `ForwardDiff.gradient`. [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) er en pakke for √• beregne gradienter numerisk. Her kan det v√¶re nyttig √• poengtere forskjellen fra hvordan dette blir gjort i boken og i Python-oversettelsen. I Python-oversettelsen brukes `np.gradient` for √• beregne gradienter numerisk, n√•r man har en matrise med skalarverdier. Julia har ikke en tilsvarende funksjon, men vi kan gj√∏re noe bedre! Vi kan bruke [automatisk differensiering](https://en.wikipedia.org/wiki/Automatic_differentiation) for √• beregne gradienten til funksjonen, gitt et vilk√•rlig punkt. Det finnes mange pakker for automatisk differensiering i Julia, men vi bruker her `ForwardDiff.jl` (legge den til MEK1100-milj√∏et i pakkemodusen!).

```{julia}
import ForwardDiff: gradient
function h(point)
    x = point[1]
    y = point[2]
    return x^2 + 2y - 0.5x*y
end
‚àáh(point) = gradient(h, point)
‚àáh([1, 2])
```
Her har vi definert en funksjon $h$, og s√• definerer vi en funksjon `‚àáh` som beregner gradienten til $h$ gitt et vilk√•rlig punkt. Vi kan s√• beregne gradienten til $h$ gitt punktet $[1, 2]$. 

Med denne gradientfunksjonen kan vi plotte gradientvektorer:

```{julia}
arrows2d(x, y, ‚àáh, lengthscale=0.04)
```


N√• skal vi bruke denne teknikken til √• plotte konturlinjer og gradientvektorer for funksjonen gitt ved @eq-Beerenberg. Med noen justeringer fra eksempelet over, kan vi gj√∏re slik:

```{julia}
using CairoMakie
using ForwardDiff: gradient

h0 = 2.277 # km
R = 4 # km

function h(point)
    x = point[1]
    y = point[2]
    return h0 / (1 + (x^2 + y^2) / R^2)
end

‚àáh(point) = gradient(h, point)

nx = 41
ny = 41
x = LinRange(-10, 10, nx)
y = LinRange(-10, 10, ny)
points = Point2f.(x, y') # matrise med punkter
z = h.(points)


x_gradient = LinRange(-10, 10, 11)
y_gradient = LinRange(-10, 10, 11)


fig = Figure()
ax = Axis(fig[1, 1], xlabel="x [km]", ylabel="y [km]", aspect=DataAspect())
arrows2d!(ax, x_gradient, y_gradient, ‚àáh, lengthscale=5)
contour!(ax, x, y, z, linewidth=2)
fig
```

Her legger vi merke til at vektorene st√•r vinkelrett p√• konturlinjene, akkurat som vi skulle ha forventet. For √• sikre at dette ser riktig ut, er det viktig √• bruke `DataAspect()` p√• aksen, slik at aksene ikke blir forskjellige skalerte.

Ettersom `ForwardDiff.gradient` tar inn funksjoner som tar inn et punkt, definerer vi `h` som en funksjon som tar inn et punkt. For √• beregne matrisen med z-verdier, bruker vi `h.(points)`, alts√• regner vi ut $h$ elementvis for alle punktene i matrisen (et element er et punkt).


## 3.6 Plotting av str√∏mlinjer
I kapittel 4 m√∏ter vi str√∏mfunksjonen $\psi$. Kjenner vi uttrykket for denne er det lett √• plotte str√∏mlinjene. Siden str√∏mfunksjonen er konstant langs en str√∏mlinje vil str√∏mlinjene v√¶re konturlinjer for skalarfeltet $\psi$. Vi kan derfor definere et grid med en x- og en y-vektor som tidligere, regne ut diskrete verdier av str√∏mfunksjonen for hvert punkt i gridet, og til slutt bruke contour-funksjonen for √• plotte str√∏mlinjene, p√• samme m√•te som vi plottet isobarene til trykkfeltet i seksjon @sec-konturlinjer.

::: {.callout-note}
Noen ganger √∏nsker vi √• plotte str√∏mlinjer og ekviskalarflater i samme plott. I s√• fall er det et viktig poeng at de kurvefamiliene st√•r vinkelrett p√• hverandre. Dette oppn√•s ved √• kreve at enhetene langs begge aksene er like, derfor bruker vi `DataAspect()` p√• aksen.
:::

## 3.7 Oppgaver
Oppgavene som st√•r i boka anbefales og kan gj√∏res uansett om man bruker Matlab, Python, eller Julia. 